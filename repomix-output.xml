This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    convex_rules.mdc
    project.mdc
    type_route_rules.mdc
convex/
  _generated/
    api.d.ts
    api.js
    dataModel.d.ts
    server.d.ts
    server.js
  agents/
    internalMutations.ts
    internalQueries.ts
    model.ts
    mutations.ts
    queries.ts
    schema.ts
  ai/
    agentReplyToMessage.ts
    history.ts
    instructions.ts
    messages.ts
    tools.ts
    triageMessage.ts
    utils.ts
  conversationMessages/
    internalActions.ts
    internalMutations.ts
    internalQueries.ts
    model.ts
    mutations.ts
    queries.ts
    schema.ts
  conversationParticipants/
    internalMutations.ts
    internalQueries.ts
    model.ts
    mutations.ts
    queries.ts
    schema.ts
  conversations/
    internalMutations.ts
    internalQueries.ts
    model.ts
    mutations.ts
    queries.ts
  users/
    model.ts
    queries.ts
  auth.config.ts
  auth.ts
  http.ts
  README.md
  schema.ts
  tsconfig.json
public/
  convex.svg
  logo.svg
shared/
  ensure.ts
  filter.ts
  mentions.test.ts
  mentions.ts
  misc.ts
  predefinedAgents.ts
  tools.ts
src/
  components/
    authenticated/
      agents/
        AgentDescription.tsx
        AgentPersonality.tsx
        AgentProfile.tsx
        AgentTools.tsx
      chat/
        AgentMention.tsx
        AgentSelector.tsx
        BaseMention.tsx
        ChatArea.tsx
        ChatContext.tsx
        ChatInput.tsx
        ChatMessage.tsx
        ConversationHeader.tsx
        ConversationParticipants.tsx
        ParticipantMessage.tsx
        ParticipantsDialog.tsx
        SystemMessage.tsx
        ThinkingIndicator.tsx
        UserMention.tsx
      conversations/
        ConversationItem.tsx
        ConversationList.tsx
        UserProfile.tsx
      sidebar/
        AgentList.tsx
        ConversationList.tsx
        Sidebar.tsx
      AuthenticatedContent.tsx
      SignOutButton.tsx
    misc/
      errors.ts
      hooks.ts
    ui/
      agent-avatar.tsx
      avatar.tsx
      badge.tsx
      button.tsx
      card.tsx
      confirm.tsx
      dialog.tsx
      dropdown-menu.tsx
      editable-text.tsx
      input.tsx
      label.tsx
      skeleton.tsx
      textarea.tsx
      tooltip.tsx
    unauthenticated/
      SignInForm.tsx
      SignInWithGithub.tsx
      SignInWithPassword.tsx
      UnauthenticatedContent.tsx
  lib/
    utils.ts
  App.tsx
  index.css
  main.tsx
  routes.ts
  vite-env.d.ts
.eslintrc.cjs
.gitattributes
.gitignore
.prettierrc
components.json
index.html
LICENSE
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/convex_rules.mdc">
---
description: Guidelines and best practices for building Convex projects, including database schema design, queries, mutations, and real-world examples
globs: **/*.ts,**/*.tsx,**/*.js,**/*.jsx
alwaysApply: false
---

# Convex guidelines
## Function guidelines
### New function syntax
- ALWAYS use the new function syntax for Convex functions. For example:
      ```typescript
      import { query } from "./_generated/server";
      import { v } from "convex/values";
      export const f = query({
          args: {},
          returns: v.null(),
          handler: async (ctx, args) => {
          // Function body
          },
      });
      ```

### Http endpoint syntax
- HTTP endpoints are defined in `convex/http.ts` and require an `httpAction` decorator. For example:
      ```typescript
      import { httpRouter } from "convex/server";
      import { httpAction } from "./_generated/server";
      const http = httpRouter();
      http.route({
          path: "/echo",
          method: "POST",
          handler: httpAction(async (ctx, req) => {
          const body = await req.bytes();
          return new Response(body, { status: 200 });
          }),
      });
      ```
- HTTP endpoints are always registered at the exact path you specify in the `path` field. For example, if you specify `/api/someRoute`, the endpoint will be registered at `/api/someRoute`.

### Validators
- Below is an example of an array validator:
                            ```typescript
                            import { mutation } from "./_generated/server";
                            import { v } from "convex/values";

                            export default mutation({
                            args: {
                                simpleArray: v.array(v.union(v.string(), v.number())),
                            },
                            handler: async (ctx, args) => {
                                //...
                            },
                            });
                            ```
- Below is an example of a schema with validators that codify a discriminated union type:
                            ```typescript
                            import { defineSchema, defineTable } from "convex/server";
                            import { v } from "convex/values";

                            export default defineSchema({
                                results: defineTable(
                                    v.union(
                                        v.object({
                                            kind: v.literal("error"),
                                            errorMessage: v.string(),
                                        }),
                                        v.object({
                                            kind: v.literal("success"),
                                            value: v.number(),
                                        }),
                                    ),
                                )
                            });
                            ```
- Always use the `v.null()` validator when returning a null value. Below is an example query that returns a null value:
                                  ```typescript
                                  import { query } from "./_generated/server";
                                  import { v } from "convex/values";

                                  export const exampleQuery = query({
                                    args: {},
                                    returns: v.null(),
                                    handler: async (ctx, args) => {
                                        console.log("This query returns a null value");
                                        return null;
                                    },
                                  });
                                  ```

### Function registration
- Use `internalQuery`, `internalMutation`, and `internalAction` to register internal functions. These functions are private and aren't part of an app's API. They can only be called by other Convex functions. These functions are always imported from `./_generated/server`.
- Use `query`, `mutation`, and `action` to register public functions. These functions are part of the public API and are exposed to the public Internet. Do NOT use `query`, `mutation`, or `action` to register sensitive internal functions that should be kept private.
- You CANNOT register a function through the `api` or `internal` objects.
- ALWAYS include argument and return validators for all Convex functions. This includes all of `query`, `internalQuery`, `mutation`, `internalMutation`, `action`, and `internalAction`. If a function doesn't return anything, include `returns: v.null()` as its output validator.
- If the JavaScript implementation of a Convex function doesn't have a return value, it implicitly returns `null`.

### Function calling
- Use `ctx.runQuery` to call a query from a query, mutation, or action.
- Use `ctx.runMutation` to call a mutation from a mutation or action.
- Use `ctx.runAction` to call an action from an action.
- ONLY call an action from another action if you need to cross runtimes (e.g. from V8 to Node). Otherwise, pull out the shared code into a helper async function and call that directly instead.
- Try to use as few calls from actions to queries and mutations as possible. Queries and mutations are transactions, so splitting logic up into multiple calls introduces the risk of race conditions.
- All of these calls take in a `FunctionReference`. Do NOT try to pass the callee function directly into one of these calls.
- When using `ctx.runQuery`, `ctx.runMutation`, or `ctx.runAction` to call a function in the same file, specify a type annotation on the return value to work around TypeScript circularity limitations. For example,
                            ```
                            export const f = query({
                              args: { name: v.string() },
                              returns: v.string(),
                              handler: async (ctx, args) => {
                                return "Hello " + args.name;
                              },
                            });

                            export const g = query({
                              args: {},
                              returns: v.null(),
                              handler: async (ctx, args) => {
                                const result: string = await ctx.runQuery(api.example.f, { name: "Bob" });
                                return null;
                              },
                            });
                            ```

### Function references
- Function references are pointers to registered Convex functions.
- Use the `api` object defined by the framework in `convex/_generated/api.ts` to call public functions registered with `query`, `mutation`, or `action`.
- Use the `internal` object defined by the framework in `convex/_generated/api.ts` to call internal (or private) functions registered with `internalQuery`, `internalMutation`, or `internalAction`.
- Convex uses file-based routing, so a public function defined in `convex/example.ts` named `f` has a function reference of `api.example.f`.
- A private function defined in `convex/example.ts` named `g` has a function reference of `internal.example.g`.
- Functions can also registered within directories nested within the `convex/` folder. For example, a public function `h` defined in `convex/messages/access.ts` has a function reference of `api.messages.access.h`.

### Api design
- Convex uses file-based routing, so thoughtfully organize files with public query, mutation, or action functions within the `convex/` directory.
- Use `query`, `mutation`, and `action` to define public functions.
- Use `internalQuery`, `internalMutation`, and `internalAction` to define private, internal functions.

### Pagination
- Paginated queries are queries that return a list of results in incremental pages.
- You can define pagination using the following syntax:

                            ```ts
                            import { v } from "convex/values";
                            import { query, mutation } from "./_generated/server";
                            import { paginationOptsValidator } from "convex/server";
                            export const listWithExtraArg = query({
                                args: { paginationOpts: paginationOptsValidator, author: v.string() },
                                handler: async (ctx, args) => {
                                    return await ctx.db
                                    .query("messages")
                                    .filter((q) => q.eq(q.field("author"), args.author))
                                    .order("desc")
                                    .paginate(args.paginationOpts);
                                },
                            });
                            ```
- A query that ends in `.paginate()` returns an object that has the following properties:
                            - page (contains an array of documents that you fetches)
                            - isDone (a boolean that represents whether or not this is the last page of documents)
                            - continueCursor (a string that represents the cursor to use to fetch the next page of documents)


## Validator guidelines
- `v.bigint()` is deprecated for representing signed 64-bit integers. Use `v.int64()` instead.
- Use `v.record()` for defining a record type. `v.map()` and `v.set()` are not supported.

## Schema guidelines
- Always define your schema in `convex/schema.ts`.
- Always import the schema definition functions from `convex/server`:
- System fields are automatically added to all documents and are prefixed with an underscore.
- Always include all index fields in the index name. For example, if an index is defined as `["field1", "field2"]`, the index name should be "by_field1_and_field2".
- Index fields must be queried in the same order they are defined. If you want to be able to query by "field1" then "field2" and by "field2" then "field1", you must create separate indexes.

## Typescript guidelines
- You can use the helper typescript type `Id` imported from './_generated/dataModel' to get the type of the id for a given table. For example if there is a table called 'users' you can use `Id<'users'>` to get the type of the id for that table.
- If you need to define a `Record` make sure that you correctly provide the type of the key and value in the type. For example a validator `v.record(v.id('users'), v.string())` would have the type `Record<Id<'users'>, string>`. Below is an example of using `Record` with an `Id` type in a query:
                    ```ts
                    import { query } from "./_generated/server";
                    import { Doc, Id } from "./_generated/dataModel";

                    export const exampleQuery = query({
                        args: { userIds: v.array(v.id("users")) },
                        returns: v.record(v.id("users"), v.string()),
                        handler: async (ctx, args) => {
                            const idToUsername: Record<Id<"users">, string> = {};
                            for (const userId of args.userIds) {
                                const user = await ctx.db.get(userId);
                                if (user) {
                                    users[user._id] = user.username;
                                }
                            }

                            return idToUsername;
                        },
                    });
                    ```
- Be strict with types, particularly around id's of documents. For example, if a function takes in an id for a document in the 'users' table, take in `Id<'users'>` rather than `string`.
- Always use `as const` for string literals in discriminated union types.
- When using the `Array` type, make sure to always define your arrays as `const array: Array<T> = [...];`
- When using the `Record` type, make sure to always define your records as `const record: Record<KeyType, ValueType> = {...};`
- Always add `@types/node` to your `package.json` when using any Node.js built-in modules.

## Full text search guidelines
- A query for "10 messages in channel '#general' that best match the query 'hello hi' in their body" would look like:

const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) =>
    q.search("body", "hello hi").eq("channel", "#general"),
  )
  .take(10);

## Query guidelines
- Do NOT use `filter` in queries. Instead, define an index in the schema and use `withIndex` instead.
- Convex queries do NOT support `.delete()`. Instead, `.collect()` the results, iterate over them, and call `ctx.db.delete(row._id)` on each result.
- Use `.unique()` to get a single document from a query. This method will throw an error if there are multiple documents that match the query.
- When using async iteration, don't use `.collect()` or `.take(n)` on the result of a query. Instead, use the `for await (const row of query)` syntax.
### Ordering
- By default Convex always returns documents in ascending `_creationTime` order.
- You can use `.order('asc')` or `.order('desc')` to pick whether a query is in ascending or descending order. If the order isn't specified, it defaults to ascending.
- Document queries that use indexes will be ordered based on the columns in the index and can avoid slow table scans.


## Mutation guidelines
- Use `ctx.db.replace` to fully replace an existing document. This method will throw an error if the document does not exist.
- Use `ctx.db.patch` to shallow merge updates into an existing document. This method will throw an error if the document does not exist.

## Action guidelines
- Always add `"use node";` to the top of files containing actions that use Node.js built-in modules.
- Never use `ctx.db` inside of an action. Actions don't have access to the database.
- Below is an example of the syntax for an action:
                    ```ts
                    import { action } from "./_generated/server";

                    export const exampleAction = action({
                        args: {},
                        returns: v.null(),
                        handler: async (ctx, args) => {
                            console.log("This action does not return anything");
                            return null;
                        },
                    });
                    ```

## Scheduling guidelines
### Cron guidelines
- Only use the `crons.interval` or `crons.cron` methods to schedule cron jobs. Do NOT use the `crons.hourly`, `crons.daily`, or `crons.weekly` helpers.
- Both cron methods take in a FunctionReference. Do NOT try to pass the function directly into one of these methods.
- Define crons by declaring the top-level `crons` object, calling some methods on it, and then exporting it as default. For example,
                            ```ts
                            import { cronJobs } from "convex/server";
                            import { internal } from "./_generated/api";
                            import { internalAction } from "./_generated/server";

                            const empty = internalAction({
                              args: {},
                              returns: v.null(),
                              handler: async (ctx, args) => {
                                console.log("empty");
                              },
                            });

                            const crons = cronJobs();

                            // Run `internal.crons.empty` every two hours.
                            crons.interval("delete inactive users", { hours: 2 }, internal.crons.empty, {});

                            export default crons;
                            ```
- You can register Convex functions within `crons.ts` just like any other file.
- If a cron calls an internal function, always import the `internal` object from '_generated/api`, even if the internal function is registered in the same file.


## File storage guidelines
- Convex includes file storage for large files like images, videos, and PDFs.
- The `ctx.storage.getUrl()` method returns a signed URL for a given file. It returns `null` if the file doesn't exist.
- Do NOT use the deprecated `ctx.storage.getMetadata` call for loading a file's metadata.

                    Instead, query the `_storage` system table. For example, you can use `ctx.db.system.get` to get an `Id<"_storage">`.
                    ```
                    import { query } from "./_generated/server";
                    import { Id } from "./_generated/dataModel";

                    type FileMetadata = {
                        _id: Id<"_storage">;
                        _creationTime: number;
                        contentType?: string;
                        sha256: string;
                        size: number;
                    }

                    export const exampleQuery = query({
                        args: { fileId: v.id("_storage") },
                        returns: v.null();
                        handler: async (ctx, args) => {
                            const metadata: FileMetadata | null = await ctx.db.system.get(args.fileId);
                            console.log(metadata);
                            return null;
                        },
                    });
                    ```
- Convex storage stores items as `Blob` objects. You must convert all items to/from a `Blob` when using Convex storage.


# Examples:
## Example: chat-app

### Task
```
Create a real-time chat application backend with AI responses. The app should:
- Allow creating users with names
- Support multiple chat channels
- Enable users to send messages to channels
- Automatically generate AI responses to user messages
- Show recent message history

The backend should provide APIs for:
1. User management (creation)
2. Channel management (creation)
3. Message operations (sending, listing)
4. AI response generation using OpenAI's GPT-4

Messages should be stored with their channel, author, and content. The system should maintain message order
and limit history display to the 10 most recent messages per channel.

```

### Analysis
1. Task Requirements Summary:
- Build a real-time chat backend with AI integration
- Support user creation
- Enable channel-based conversations
- Store and retrieve messages with proper ordering
- Generate AI responses automatically

2. Main Components Needed:
- Database tables: users, channels, messages
- Public APIs for user/channel management
- Message handling functions
- Internal AI response generation system
- Context loading for AI responses

3. Public API and Internal Functions Design:
Public Mutations:
- createUser:
  - file path: convex/index.ts
  - arguments: {name: v.string()}
  - returns: v.object({userId: v.id("users")})
  - purpose: Create a new user with a given name
- createChannel:
  - file path: convex/index.ts
  - arguments: {name: v.string()}
  - returns: v.object({channelId: v.id("channels")})
  - purpose: Create a new channel with a given name
- sendMessage:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels"), authorId: v.id("users"), content: v.string()}
  - returns: v.null()
  - purpose: Send a message to a channel and schedule a response from the AI

Public Queries:
- listMessages:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.array(v.object({
    _id: v.id("messages"),
    _creationTime: v.number(),
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
    }))
  - purpose: List the 10 most recent messages from a channel in descending creation order

Internal Functions:
- generateResponse:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.null()
  - purpose: Generate a response from the AI for a given channel
- loadContext:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.array(v.object({
    _id: v.id("messages"),
    _creationTime: v.number(),
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
  }))
- writeAgentResponse:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels"), content: v.string()}
  - returns: v.null()
  - purpose: Write an AI response to a given channel

4. Schema Design:
- users
  - validator: { name: v.string() }
  - indexes: <none>
- channels
  - validator: { name: v.string() }
  - indexes: <none>
- messages
  - validator: { channelId: v.id("channels"), authorId: v.optional(v.id("users")), content: v.string() }
  - indexes
    - by_channel: ["channelId"]

5. Background Processing:
- AI response generation runs asynchronously after each user message
- Uses OpenAI's GPT-4 to generate contextual responses
- Maintains conversation context using recent message history


### Implementation

#### package.json
```typescript
{
  "name": "chat-app",
  "description": "This example shows how to build a chat app without authentication.",
  "version": "1.0.0",
  "dependencies": {
    "convex": "^1.17.4",
    "openai": "^4.79.0"
  },
  "devDependencies": {
    "typescript": "^5.7.3"
  }
}
```

#### tsconfig.json
```typescript
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "exclude": ["convex"],
  "include": ["**/src/**/*.tsx", "**/src/**/*.ts", "vite.config.ts"]
}
```

#### convex/index.ts
```typescript
import {
  query,
  mutation,
  internalQuery,
  internalMutation,
  internalAction,
} from "./_generated/server";
import { v } from "convex/values";
import OpenAI from "openai";
import { internal } from "./_generated/api";

/**
 * Create a user with a given name.
 */
export const createUser = mutation({
  args: {
    name: v.string(),
  },
  returns: v.id("users"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("users", { name: args.name });
  },
});

/**
 * Create a channel with a given name.
 */
export const createChannel = mutation({
  args: {
    name: v.string(),
  },
  returns: v.id("channels"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("channels", { name: args.name });
  },
});

/**
 * List the 10 most recent messages from a channel in descending creation order.
 */
export const listMessages = query({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.array(
    v.object({
      _id: v.id("messages"),
      _creationTime: v.number(),
      channelId: v.id("channels"),
      authorId: v.optional(v.id("users")),
      content: v.string(),
    }),
  ),
  handler: async (ctx, args) => {
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", args.channelId))
      .order("desc")
      .take(10);
    return messages;
  },
});

/**
 * Send a message to a channel and schedule a response from the AI.
 */
export const sendMessage = mutation({
  args: {
    channelId: v.id("channels"),
    authorId: v.id("users"),
    content: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const channel = await ctx.db.get(args.channelId);
    if (!channel) {
      throw new Error("Channel not found");
    }
    const user = await ctx.db.get(args.authorId);
    if (!user) {
      throw new Error("User not found");
    }
    await ctx.db.insert("messages", {
      channelId: args.channelId,
      authorId: args.authorId,
      content: args.content,
    });
    await ctx.scheduler.runAfter(0, internal.index.generateResponse, {
      channelId: args.channelId,
    });
    return null;
  },
});

const openai = new OpenAI();

export const generateResponse = internalAction({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const context = await ctx.runQuery(internal.index.loadContext, {
      channelId: args.channelId,
    });
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: context,
    });
    const content = response.choices[0].message.content;
    if (!content) {
      throw new Error("No content in response");
    }
    await ctx.runMutation(internal.index.writeAgentResponse, {
      channelId: args.channelId,
      content,
    });
    return null;
  },
});

export const loadContext = internalQuery({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.array(
    v.object({
      role: v.union(v.literal("user"), v.literal("assistant")),
      content: v.string(),
    }),
  ),
  handler: async (ctx, args) => {
    const channel = await ctx.db.get(args.channelId);
    if (!channel) {
      throw new Error("Channel not found");
    }
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", args.channelId))
      .order("desc")
      .take(10);

    const result = [];
    for (const message of messages) {
      if (message.authorId) {
        const user = await ctx.db.get(message.authorId);
        if (!user) {
          throw new Error("User not found");
        }
        result.push({
          role: "user" as const,
          content: `${user.name}: ${message.content}`,
        });
      } else {
        result.push({ role: "assistant" as const, content: message.content });
      }
    }
    return result;
  },
});

export const writeAgentResponse = internalMutation({
  args: {
    channelId: v.id("channels"),
    content: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.insert("messages", {
      channelId: args.channelId,
      content: args.content,
    });
    return null;
  },
});
```

#### convex/schema.ts
```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  channels: defineTable({
    name: v.string(),
  }),

  users: defineTable({
    name: v.string(),
  }),

  messages: defineTable({
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
  }).index("by_channel", ["channelId"]),
});
```

#### src/App.tsx
```typescript
export default function App() {
  return <div>Hello World</div>;
}
```
</file>

<file path=".cursor/rules/type_route_rules.mdc">
---
description: 
globs: *.tsx,*.ts
alwaysApply: false
---
# Type Route Guidelines

See https://type-route.zilch.dev/ for more

## Basic Setup

### Route Definition
- ALWAYS use `defineRoute` to define routes with proper parameter types:
```typescript
import { createRouter, defineRoute, param } from "type-route";

export const { RouteProvider, useRoute, routes } = createRouter({
  home: defineRoute("/"),
  detail: defineRoute(
    {
      id: param.path.string,
      tab: param.query.optional.string,
    },
    (p) => `/detail/${p.id}`
  ),
});
```

### Parameter Types
- Use `param.path` for URL path parameters
- Use `param.query` for query string parameters
- Use `param.query.optional` for optional query parameters
- Available parameter types:
  - `string`
  - `number`
  - `boolean`
  - `array`

### Route Provider Setup
- Wrap your app with `RouteProvider`:
```typescript
import { RouteProvider } from "./routes";

function App() {
  return (
    <RouteProvider>
      <YourApp />
    </RouteProvider>
  );
}
```

## Navigation

### Link Navigation
- Use the `link` property for anchor tags:
```typescript
<a {...routes.detail({ id: "123" }).link}>
  View Details
</a>
```

### Programmatic Navigation
- Use `push()` for regular navigation:
```typescript
routes.detail({ id: "123" }).push();
```
- Use `replace()` to replace current history entry:
```typescript
routes.detail({ id: "123" }).replace();
```

## Route Helpers

### Current Route Access
- Use `useRoute()` to get current route info:
```typescript
const route = useRoute();
if (route.name === "detail") {
  console.log(route.params.id);
}
```

### Type Safety
- Route parameters are fully typed
- TypeScript will catch invalid parameter types
- Route names are type-safe in switch statements

## Best Practices

### Route Organization
- Keep all routes in a single `routes.ts` file
- Export helper hooks for common route operations
- Example helper hook:
```typescript
export function useCurrentId(): string | undefined {
  const route = useRoute();
  if (route.name === "detail")
    return route.params.id;
  return undefined;
}
```

### Route Parameters
- Use path parameters for required values
- Use query parameters for optional values
- Keep parameter names descriptive and consistent

### Type Safety
- Let TypeScript infer route parameter types
- Don't use type assertions unless absolutely necessary
- Validate parameters before using them in components

### Navigation
- Prefer declarative navigation with `link` over imperative with `push`
- Handle navigation errors gracefully
- Consider using route helpers for complex navigation logic

## Common Patterns

### Optional Parameters
```typescript
const route = defineRoute(
  {
    id: param.path.string,
    view: param.query.optional.string,
  },
  (p) => `/item/${p.id}`
);
```

### Nested Routes
```typescript
const routes = {
  users: defineRoute("/users"),
  userDetail: defineRoute(
    { id: param.path.string },
    (p) => `/users/${p.id}`
  ),
  userSettings: defineRoute(
    { id: param.path.string },
    (p) => `/users/${p.id}/settings`
  ),
};
```

### Route Groups
```typescript
const routes = {
  home: defineRoute("/"),
  auth: {
    login: defineRoute("/auth/login"),
    register: defineRoute("/auth/register"),
    forgot: defineRoute("/auth/forgot"),
  },
};
```
</file>

<file path="convex/_generated/api.js">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;
</file>

<file path="convex/_generated/dataModel.d.ts">
/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;
</file>

<file path="convex/_generated/server.d.ts">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;
</file>

<file path="convex/_generated/server.js">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;
</file>

<file path="convex/auth.config.ts">
export default {
  providers: [
    {
      domain: process.env.CONVEX_SITE_URL,
      applicationID: "convex",
    },
    {
      domain: process.env.CONVEX_SITE_URL,
      applicationID: "password",
      validatePassword: async (password: string) => {
        // In a real app, you'd want to enforce password strength
        return true;
      },
    },
  ],
};
</file>

<file path="convex/auth.ts">
import { convexAuth } from "@convex-dev/auth/server";
import { Password } from "@convex-dev/auth/providers/Password";
import GitHub from "@auth/core/providers/github";

export const { auth, signIn, signOut, store, isAuthenticated } = convexAuth({
  providers: [GitHub, Password],
});
</file>

<file path="convex/http.ts">
import { httpRouter } from "convex/server";
import { auth } from "./auth";

const http = httpRouter();

auth.addHttpRoutes(http);

export default http;
</file>

<file path="public/convex.svg">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 367 370" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1,0,0,1,-129.225,-127.948)">
        <g id="Layer-1" serif:id="Layer 1" transform="matrix(4.16667,0,0,4.16667,0,0)">
            <g transform="matrix(1,0,0,1,86.6099,107.074)">
                <path d="M0,-6.544C13.098,-7.973 25.449,-14.834 32.255,-26.287C29.037,2.033 -2.48,19.936 -28.196,8.94C-30.569,7.925 -32.605,6.254 -34.008,4.088C-39.789,-4.83 -41.69,-16.18 -38.963,-26.48C-31.158,-13.247 -15.3,-5.131 0,-6.544" style="fill:rgb(245,176,26);fill-rule:nonzero;"/>
            </g>
            <g transform="matrix(1,0,0,1,47.1708,74.7779)">
                <path d="M0,-2.489C-5.312,9.568 -5.545,23.695 0.971,35.316C-21.946,18.37 -21.692,-17.876 0.689,-34.65C2.754,-36.197 5.219,-37.124 7.797,-37.257C18.41,-37.805 29.19,-33.775 36.747,-26.264C21.384,-26.121 6.427,-16.446 0,-2.489" style="fill:rgb(141,37,118);fill-rule:nonzero;"/>
            </g>
            <g transform="matrix(1,0,0,1,91.325,66.4152)">
                <path d="M0,-14.199C-7.749,-24.821 -19.884,-32.044 -33.173,-32.264C-7.482,-43.726 24.112,-25.143 27.557,2.322C27.877,4.876 27.458,7.469 26.305,9.769C21.503,19.345 12.602,26.776 2.203,29.527C9.838,15.64 8.889,-1.328 0,-14.199" style="fill:rgb(238,52,47);fill-rule:nonzero;"/>
            </g>
        </g>
    </g>
</svg>
</file>

<file path="src/components/authenticated/SignOutButton.tsx">
import * as React from "react";
import { useConvexAuth } from "convex/react";
import { useAuthActions } from "@convex-dev/auth/react";
import { Button } from "../ui/button";

export const SignOutButton: React.FC = () => {
  const { isAuthenticated } = useConvexAuth();
  const { signOut } = useAuthActions();

  if (!isAuthenticated) return null;

  return (
    <Button variant="default" onClick={() => void signOut()}>
      Sign out
    </Button>
  );
};
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive cursor-pointer",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}

export { Button, buttonVariants };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-[data-slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="src/components/ui/confirm.tsx">
import * as React from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "./dialog";
import { Button } from "./button";

interface ConfirmProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description: string;
  confirmText?: string;
  cancelText?: string;
  onConfirm: () => void;
  variant?: "default" | "destructive";
}

export const Confirm: React.FC<ConfirmProps> = ({
  open,
  onOpenChange,
  title,
  description,
  confirmText = "Confirm",
  cancelText = "Cancel",
  onConfirm,
  variant = "default",
}) => {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
          <DialogDescription>{description}</DialogDescription>
        </DialogHeader>
        <DialogFooter className="gap-2">
          <Button variant="ghost" onClick={() => onOpenChange(false)}>
            {cancelText}
          </Button>
          <Button variant={variant} onClick={onConfirm}>
            {confirmText}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="src/components/ui/dialog.tsx">
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-gray-300/50", className)}
      {...props}
    />
  );
}

export { Skeleton };
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="src/components/unauthenticated/SignInForm.tsx">
import * as React from "react";
import { Card, CardContent, CardHeader } from "../ui/card";
import { SignInWithGithub } from "./SignInWithGithub";

export const SignInForm: React.FC = () => (
  <Card className="w-96 mx-auto">
    <CardHeader>
      <h2 className="text-lg text-center">
        Welcome! Please sign in to continue
      </h2>
    </CardHeader>
    <CardContent className="flex justify-center">
      <SignInWithGithub />
    </CardContent>
  </Card>
);
</file>

<file path="src/components/unauthenticated/SignInWithGithub.tsx">
import { useAuthActions } from "@convex-dev/auth/react";
import { Button } from "../ui/button";

export function SignInWithGithub() {
  const { signIn } = useAuthActions();
  return (
    <Button
      onClick={() => void signIn("github")}
      variant="outline"
      className="w-full h-10 bg-black hover:bg-black/90 text-white border-black"
    >
      <svg viewBox="0 0 98 96" className="mr-2 h-4 w-4 fill-current">
        <path d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" />
      </svg>
      Sign in with GitHub
    </Button>
  );
}
</file>

<file path="src/components/unauthenticated/SignInWithPassword.tsx">
import { useState } from "react";
import { useAuthActions } from "@convex-dev/auth/react";
import { Button } from "../ui/button";

export function SignInWithPassword({
  onModeChange,
}: {
  onModeChange?: (mode: "signIn" | "signUp") => void;
}) {
  const { signIn } = useAuthActions();
  const [step, setStep] = useState<"signUp" | "signIn">("signIn");

  const toggleStep = (newStep: "signUp" | "signIn") => {
    setStep(newStep);
    if (onModeChange) onModeChange(newStep);
  };

  return (
    <div className="flex flex-col gap-4 w-full">
      <div className="text-center"></div>
      <form
        className="flex flex-col gap-4"
        onSubmit={async (e) => {
          e.preventDefault();
          const formData = new FormData(e.currentTarget);
          await signIn("password", formData);
        }}
      >
        <input
          name="email"
          type="email"
          placeholder="Email"
          required
          className="p-2 border rounded bg-background"
        />
        <input
          name="password"
          type="password"
          placeholder="Password"
          required
          className="p-2 border rounded bg-background"
        />
        <input name="flow" type="hidden" value={step} />
        <div className="flex flex-col gap-2">
          <Button type="submit" className="w-full">
            {step === "signIn" ? "Sign in" : "Sign up"}
          </Button>
          <Button
            type="button"
            variant="ghost"
            className="text-sm"
            onClick={() => toggleStep(step === "signIn" ? "signUp" : "signIn")}
          >
            {step === "signIn"
              ? "Don't have an account? Sign up"
              : "Already have an account? Sign in"}
          </Button>
        </div>
      </form>
    </div>
  );
}
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/index.css">
@import "tailwindcss";

@plugin "tailwindcss-animate";

@custom-variant dark (&:is(.dark *));

@layer base {
  :root {
    --radius: 0.5rem;
    --background: #EAE9E9;
    --foreground: #1A1A1A;
    --card: #FFFFFF;
    --card-foreground: #1A1A1A;
    --popover: #FFFFFF;
    --popover-foreground: #1A1A1A;
    --primary: #669abd;
    --primary-foreground: #FFFFFF;
    --secondary: #F4F3F3;
    --secondary-foreground: #1A1A1A;
    --muted: #F4F3F3;
    --muted-foreground: #666666;
    --accent: #5b9eca;
    --accent-foreground: #FFFFFF;
    --destructive: #DC2626;
    --destructive-foreground: #FFFFFF;
    --border: #D1D0D0;
    --input: #D1D0D0;
    --ring: #2E90D0;
  }

  .dark {
    --background: #1A1A1A;
    --foreground: #EAE9E9;
    --card: #262626;
    --card-foreground: #EAE9E9;
    --popover: #262626;
    --popover-foreground: #EAE9E9;
    --primary: #2E90D0;
    --primary-foreground: #FFFFFF;
    --secondary: #333333;
    --secondary-foreground: #EAE9E9;
    --muted: #333333;
    --muted-foreground: #999999;
    --accent: #2e2e2e;
    --accent-foreground: #FFFFFF;
    --destructive: #DC2626;
    --destructive-foreground: #FFFFFF;
    --border: #404040;
    --input: #333333;
    --ring: #2E90D0;
  }

  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}
</file>

<file path="src/main.tsx">
import { ConvexAuthProvider } from "@convex-dev/auth/react";
import React from "react";
import ReactDOM from "react-dom/client";
import { ConvexReactClient } from "convex/react";
import App from "./App.tsx";
import "./index.css";
import { routes } from "./routes";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ConvexAuthProvider client={convex}>
      <App />
    </ConvexAuthProvider>
  </React.StrictMode>,
);
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path=".eslintrc.cjs">
module.exports = {
  root: true,
  env: { browser: true, es2020: true, node: true },
  extends: [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended-type-checked",
    "plugin:react-hooks/recommended",
  ],
  ignorePatterns: [
    "dist",
    ".eslintrc.cjs",
    "convex/_generated",
    "postcss.config.js",
    "tailwind.config.js",
    "vite.config.ts",
    // shadcn components by default violate some rules
    "src/components/ui",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    EXPERIMENTAL_useProjectService: true,
  },
  plugins: ["react-refresh"],
  rules: {
    "react-refresh/only-export-components": [
      "warn",
      { allowConstantExport: true },
    ],

    // All of these overrides ease getting into
    // TypeScript, and can be removed for stricter
    // linting down the line.

    // Only warn on unused variables, and ignore variables starting with `_`
    "@typescript-eslint/no-unused-vars": [
      "warn",
      { varsIgnorePattern: "^_", argsIgnorePattern: "^_" },
    ],

    // Allow escaping the compiler
    "@typescript-eslint/ban-ts-comment": "error",

    // Allow explicit `any`s
    "@typescript-eslint/no-explicit-any": "off",

    // START: Allow implicit `any`s
    "@typescript-eslint/no-unsafe-argument": "off",
    "@typescript-eslint/no-unsafe-assignment": "off",
    "@typescript-eslint/no-unsafe-call": "off",
    "@typescript-eslint/no-unsafe-member-access": "off",
    "@typescript-eslint/no-unsafe-return": "off",
    // END: Allow implicit `any`s

    // Allow async functions without await
    // for consistency (esp. Convex `handler`s)
    "@typescript-eslint/require-await": "off",
  },
};
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
</file>

<file path=".prettierrc">
{}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/convex.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
    <link rel="stylesheet" href="/src/index.css" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Mike Cann

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.node.json"
    }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "noEmit": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import tailwindcss from "@tailwindcss/vite";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  server: {
    port: 5173,
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path="convex/agents/internalMutations.ts">
import { internalMutation } from "../_generated/server";
import { systemAgentValidator } from "./schema";
import * as Agents from "./model";

export const createSystemAgent = internalMutation({
  args: systemAgentValidator,
  handler: async (ctx, args) => {
    const existringAgent = await Agents.findSystemAgentByKind(ctx.db, {
      systemAgentKind: args.systemAgentKind,
    });
    if (existringAgent) return existringAgent;
    await Agents.createSystemAgent(ctx, args);
    return Agents.getSystemAgentByKind(ctx.db, {
      systemAgentKind: args.systemAgentKind,
    });
  },
});
</file>

<file path="convex/agents/internalQueries.ts">
import {internalQuery} from '../_generated/server';
import {systemAgentKindValidator} from './schema';
import * as Agents from './model';
import {v} from 'convex/values';
import {listForUser} from './model';


export const findSystemAgentByKind = internalQuery({
  args: {
    systemAgentKind: systemAgentKindValidator,
  },
  handler: async (ctx, args) => {
    return await Agents.findSystemAgentByKind(ctx.db, args);
  },
});

export const listAgentsForUser = internalQuery({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    return await Agents.listForUser(ctx.db, { userId: args.userId });
  },
});


export const find = internalQuery({
  args: {
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => {
    return await Agents.find(ctx.db, args);
  },
});
</file>

<file path="convex/agents/mutations.ts">
import { mutation, query } from "../_generated/server";
import * as Agents from "./model";
import { v } from "convex/values";

export const create = mutation({
  args: {},
  handler: async (ctx) => Agents.createAgent(ctx),
});



export const updateMine = mutation({
  args: {
    agentId: v.id("agents"),
    name: v.string(),
    description: v.string(),
    personality: v.string(),
    tools: v.array(v.string()),
  },
  handler: async (ctx, args) => {
    const agent = await Agents.getMine(ctx, { agentId: args.agentId });
    if (agent.kind != "user_agent")
      throw new Error("Cannot update non user_agent");
    return Agents.updateMine(ctx, args);
  },
});

export const removeMine = mutation({
  args: {
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => {
    const agent = await Agents.getMine(ctx, { agentId: args.agentId });
    if (agent.kind != "user_agent")
      throw new Error("Cannot delete non user_agent");
    return Agents.remove(ctx, args);
  },
});

export const shuffleAvatar = mutation({
  args: {
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => {
    const agent = await Agents.getMine(ctx, args);
    return await ctx.db.patch(args.agentId, {
      avatarUrl: Agents.createAgentAvatarUrl(`${agent.name}-${Date.now()}`),
    });
  },
});
</file>

<file path="convex/agents/queries.ts">
import { query } from "../_generated/server";
import { v } from "convex/values";
import { pick } from "convex-helpers";
import { Id } from "../_generated/dataModel";
import * as Agents from "./model";

export const listMine = query({
  args: {},
  handler: async (ctx) => Agents.listMine(ctx),
});

export const getMine = query({
  args: {
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => Agents.getMine(ctx, args),
});

export const findMine = query({
  args: {
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => Agents.findMine(ctx, args),
});

export const findMention = query({
  args: {
    agentId: v.string(),
  },
  handler: async (ctx, args) => {
    try {
      const agent = await ctx.db.get(args.agentId as Id<"agents">);
      if (!agent) return null;
      return pick(agent, ["name", "_id", "avatarUrl"]);
    } catch (error) {
      // Return null if ID is invalid or any other error occurs
      return null;
    }
  },
});
</file>

<file path="convex/conversationMessages/internalQueries.ts">
import { internalQuery } from "../_generated/server";
import { v } from "convex/values";
import * as Messages from "./model";
import * as ConversationParticipants from "../conversationParticipants/model";
import { ensureFP } from "../../shared/ensure";
import { pick } from "convex-helpers";
import { exhaustiveCheck } from "../../shared/misc";

export const listMessages = internalQuery({
  args: {
    conversationId: v.id("conversations"),
    count: v.number(),
  },
  handler: async (ctx, args) => {
    return await Messages.listMessages(ctx.db, {
      conversationId: args.conversationId,
      limit: args.count,
    });
  },
});

export const listMessagesHistoryForAgentGeneration = internalQuery({
  args: {
    conversationId: v.id("conversations"),
    count: v.number(),
  },
  handler: async (ctx, args) => {
    const messages = await Messages.listMessages(ctx.db, {
      conversationId: args.conversationId,
      limit: args.count,
      kind: "participant",
    });

    const messagesWithAuthorDetails = await Promise.all(
      messages
        .filter((m) => m.kind == "participant")
        .map(async (message) => {
          const userOrAgent =
            await ConversationParticipants.getParticipantUserOrAgent(ctx.db, {
              participantId: message.authorParticipantId,
            });

          if (userOrAgent.kind == "agent")
            return {
              message,
              author: {
                ...pick(userOrAgent.agent, ["name", "_id"]),
                kind: "agent",
              } as const,
            };

          if (userOrAgent.kind == "user")
            return {
              message,
              author: {
                ...pick(userOrAgent.user, ["name", "_id"]),
                kind: "user",
              } as const,
            };

          exhaustiveCheck(userOrAgent);
        }),
    );

    return messagesWithAuthorDetails;
  },
});

export const getMessageAuthor = internalQuery({
  args: {
    messageId: v.id("conversationMessages"),
  },
  handler: async (ctx, args) => {
    const message = await ctx.db.get(args.messageId).then(ensureFP());
    if (message.kind == "system")
      throw new Error("Message is a system message");
    return await ConversationParticipants.getParticipantUserOrAgent(ctx.db, {
      participantId: message.authorParticipantId,
    });
  },
});
</file>

<file path="convex/conversationMessages/mutations.ts">
import { v } from "convex/values";
import { mutation } from "../_generated/server";
import * as Conversations from "../conversations/model";
import * as Messages from "./model";

export const sendFromMe = mutation({
  args: {
    conversationId: v.id("conversations"),
    content: v.string(),
  },
  handler: async (ctx, args) => {
    await Conversations.ensureICanAccessConversation(ctx, {
      conversationId: args.conversationId,
    });
    return Messages.addMessageToConversationFromMe(ctx, args);
  },
});
</file>

<file path="convex/conversationMessages/queries.ts">
import {query} from '../_generated/server';
import {v} from 'convex/values';
import * as Messages from './model';
import * as Conversations from '../conversations/model';

export const listForMe = query({
  args: {
    conversationId: v.id("conversations"),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    await Conversations.ensureICanAccessConversation(ctx, {
      conversationId: args.conversationId,
    });
    return Messages.listMessages(ctx.db, args);
  },
});
</file>

<file path="convex/conversationParticipants/internalMutations.ts">
import {internalMutation} from '../_generated/server';
import {v} from 'convex/values';
import * as ConversationParticipants from './model';


export const updateParticipantStatus = internalMutation({
  args: {
    participantId: v.id("conversationParticipants"),
    status: v.union(v.literal("thinking"), v.literal("inactive")),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.participantId, {
      status: args.status,
    });
    return null;
  },
});


export const addAgentIfNotAlreadyJoined = internalMutation({
  args: {
    conversationId: v.id("conversations"),
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => {
    const participant =
      await ConversationParticipants.findParticipantByConversationIdAndIdentifier(
        ctx.db,
        {
          conversationId: args.conversationId,
          identifier: {
            kind: "agent",
            agentId: args.agentId,
          },
        },
      );

    if (participant && participant.isRemoved == false) return participant;

    const participantId =
      await ConversationParticipants.addAgentAndSendJoinMessage(ctx.db, {
        conversationId: args.conversationId,
        agentId: args.agentId,
      });

    return ConversationParticipants.getParticipant(ctx.db, {
      participantId: participantId,
    });
  },
});
</file>

<file path="convex/conversationParticipants/internalQueries.ts">
import { internalQuery } from "../_generated/server";
import { v } from "convex/values";
import * as ConversationParticipants from "./model";
import { conversationParticipantIdentifierSchemaValidator } from "./schema";

export const listNonSystemAgentParticipants = internalQuery({
  args: {
    conversationId: v.id("conversations"),
  },
  handler: async (ctx, args) => {
    return await ConversationParticipants.listNonSystemAgentParticipants(
      ctx.db,
      args,
    );
  },
});

export const listNonSystemAgentParticipantsWithJoinedDetails = internalQuery({
  args: {
    conversationId: v.id("conversations"),
  },
  handler: async (ctx, args) => {
    const participants =
      await ConversationParticipants.listParticipantsWithJoinedDetails(
        ctx.db,
        args,
      );

    return participants
      .filter((p) => {
        if (p.agent && p.agent.kind == "system_agent") return null;
        return p;
      })
      .filter((p) => p !== null);
  },
});

export const findParticipantByConversationIdAndIdentifier = internalQuery({
  args: {
    conversationId: v.id("conversations"),
    identifier: conversationParticipantIdentifierSchemaValidator,
  },
  handler: async (ctx, args) => {
    return await ConversationParticipants.findParticipantByConversationIdAndIdentifier(
      ctx.db,
      args,
    );
  },
});

export const getParticipantUserOrAgent = internalQuery({
  args: {
    participantId: v.id("conversationParticipants"),
  },
  handler: async (ctx, args) => {
    return await ConversationParticipants.getParticipantUserOrAgent(ctx.db, {
      participantId: args.participantId,
    });
  },
});
</file>

<file path="convex/conversationParticipants/mutations.ts">
import { mutation } from "../_generated/server";
import { v } from "convex/values";
import * as ConversationParticipants from "./model";
import { ensureICanAccessConversation } from "../conversations/model";
import * as ConversationMessages from "../conversationMessages/model";
import { ensureICanAccessAgent } from "../agents/model";
import { addAgentAndSendJoinMessage } from "./model";

export const addAgent = mutation({
  args: {
    conversationId: v.id("conversations"),
    agentId: v.id("agents"),
  },
  handler: async (ctx, { conversationId, agentId }) => {
    await ensureICanAccessConversation(ctx, { conversationId });
    await ensureICanAccessAgent(ctx, { agentId });
    return ConversationParticipants.addAgentAndSendJoinMessage(ctx.db, {
      conversationId,
      agentId,
    });
  },
});

export const addUser = mutation({
  args: {
    conversationId: v.id("conversations"),
    userId: v.id("users"),
  },
  handler: async (ctx, { conversationId, userId }) => {
    await ensureICanAccessConversation(ctx, { conversationId });
    return ConversationParticipants.addUser(ctx.db, { conversationId, userId });
  },
});

export const removeParticipant = mutation({
  args: {
    conversationId: v.id("conversations"),
    participantId: v.id("conversationParticipants"),
  },
  handler: async (ctx, { conversationId, participantId }) => {
    await ensureICanAccessConversation(ctx, { conversationId });

    const participant =
      await ConversationParticipants.getParticipantUserOrAgent(ctx.db, {
        participantId,
      });

    if (participant.kind == "agent" && participant.agent.kind == "system_agent")
      throw new Error("Cannot remove system agent from conversation");

    await ConversationParticipants.removeParticipant(ctx.db, { participantId });

    await ConversationMessages.createParticipantLeftConversationMessage(
      ctx.db,
      {
        conversationId,
        participant,
      },
    );

    return null;
  },
});
</file>

<file path="convex/conversationParticipants/queries.ts">
import { query } from "../_generated/server";
import { v } from "convex/values";
import * as ConversationParticipants from "./model";
import { ensureICanAccessConversation } from "../conversations/model";

export const listForMe = query({
  args: { conversationId: v.id("conversations") },
  handler: async (ctx, { conversationId }) => {
    await ensureICanAccessConversation(ctx, { conversationId });
    return ConversationParticipants.getNonRemovedParticipants(ctx.db, {
      conversationId,
    });
  },
});

export const listAvatars = query({
  args: { conversationId: v.id("conversations") },
  handler: async (ctx, { conversationId }) => {
    await ensureICanAccessConversation(ctx, { conversationId });
    const participants =
      await ConversationParticipants.getNonRemovedParticipants(ctx.db, {
        conversationId,
      });

    const participantPromises = participants.map(async (p) => {
      if (p.kind === "agent") {
        const agent = await ctx.db.get(p.agentId);
        if (agent) return agent.avatarUrl;
        return null;
      } else {
        const user = await ctx.db.get(p.userId);
        if (!user) return null;
        return (
          user.image ??
          `https://api.dicebear.com/7.x/avataaars/svg?seed=${user._id}`
        );
      }
    });

    const avatars = (await Promise.all(participantPromises)).filter(
      (r) => r != null,
    );
    return avatars;
  },
});

export const listDetailsForMe = query({
  args: { conversationId: v.id("conversations") },
  handler: async (ctx, { conversationId }) => {
    const conversation = await ensureICanAccessConversation(ctx, {
      conversationId,
    });
    const participants =
      await ConversationParticipants.getNonRemovedParticipants(ctx.db, {
        conversationId,
      });

    const details = await Promise.all(
      participants.map((p) =>
        ConversationParticipants.getParticipantDetails(ctx.db, p, {
          includeDescription: true,
          isCreator: (p) =>
            p.kind === "user" && p.userId === conversation.createdBy,
        }),
      ),
    );

    return details.filter((d): d is NonNullable<typeof d> => d !== null);
  },
});

export const listThinkingParticipants = query({
  args: { conversationId: v.id("conversations") },
  handler: async (ctx, { conversationId }) => {
    await ensureICanAccessConversation(ctx, { conversationId });
    const participants = await ctx.db
      .query("conversationParticipants")
      .withIndex("by_conversationId_status", (q) =>
        q.eq("conversationId", conversationId).eq("status", "thinking"),
      )
      .collect();

    const details = await Promise.all(
      participants.map((p) =>
        ConversationParticipants.getParticipantDetails(ctx.db, p),
      ),
    );

    return details.filter((d): d is NonNullable<typeof d> => d !== null);
  },
});
</file>

<file path="convex/conversations/internalMutations.ts">
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";
import * as Conversations from "./model";

export const joinTriageAgentToConversationIfNotAlreadyJoined = internalMutation(
  {
    args: {
      conversationId: v.id("conversations"),
    },
    handler: async (ctx, args) => {
      return await Conversations.joinTriageAgentToConversationIfNotAlreadyJoined(
        ctx.db,
        args,
      );
    },
  },
);

export const update = internalMutation({
  args: {
    conversationId: v.id("conversations"),
    title: v.string(),
  },
  handler: async (ctx, args) => Conversations.update(ctx, args),
});
</file>

<file path="convex/conversations/internalQueries.ts">
import {internalQuery} from '../_generated/server';
import {v} from 'convex/values';
import * as Conversations from './model';

export const isTriageAgentJoined = internalQuery({
  args: {
    conversationId: v.id("conversations"),
  },
  handler: async (ctx, args) => {
    return await Conversations.isTriageAgentJoined(ctx.db, args);
  },
});
</file>

<file path="convex/conversations/mutations.ts">
import { mutation } from "../_generated/server";
import { v } from "convex/values";
import * as Conversations from "./model";

export const create = mutation({
  args: {
    title: v.string(),
  },
  handler: async (ctx, args) => Conversations.createConversation(ctx, args),
});

export const updateMine = mutation({
  args: {
    conversationId: v.id("conversations"),
    title: v.string(),
  },
  handler: async (ctx, args) => Conversations.updateMine(ctx, args),
});

export const removeMine = mutation({
  args: {
    conversationId: v.id("conversations"),
  },
  handler: async (ctx, args) => Conversations.removeMine(ctx, args),
});
</file>

<file path="convex/conversations/queries.ts">
import {query} from '../_generated/server';
import {v} from 'convex/values';
import * as Conversations from './model';



export const listMine = query({
  args: {},
  handler: async (ctx) => Conversations.listMine(ctx),
});

export const getMine = query({
  args: {
    conversationId: v.id("conversations"),
  },
  handler: async (ctx, args) => Conversations.getMine(ctx, args),
});

export const findMine = query({
  args: {
    conversationId: v.id("conversations"),
  },
  handler: async (ctx, args) => Conversations.findMine(ctx, args),
});
</file>

<file path="convex/users/queries.ts">
import { v } from "convex/values";
import { query } from "../_generated/server";
import * as Users from "./model";
import { pick } from "convex-helpers";
import { Id } from "../_generated/dataModel";

export const getMe = query({
  args: {},
  handler: async (ctx) => Users.getMe(ctx),
});

export const findMention = query({
  args: {
    userId: v.string(),
  },
  handler: async (ctx, args) => {
    try {
      const user = await ctx.db.get(args.userId as Id<"users">);
      if (!user) return null;
      return pick(user, ["name", "_id", "image"]);
    } catch (error) {
      // Return null if ID is invalid or any other error occurs
      return null;
    }
  },
});
</file>

<file path="public/logo.svg">
<svg width="125" height="50" viewBox="0 0 125 50" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M54.5175 50H55.0777V0.937499L56.2603 2.8125V50H56.8204V3.8125L57.9408 5.6875V50H58.5009V6.6875L59.6835 8.5625V50H60.2437V9.5625L61.364 11.5V50H61.9864V12.4375L63.1068 14.375V50H63.6669V15.3125L64.8495 17.25V50H65.4097V18.1875L66.53 20.125V50H67.0902V21.0625L68.2728 23V50H68.833V23.9375L69.9533 25.875V50H70.5757V26.8125L71.696 28.75V50H72.2562V29.6875L73.4388 31.625V50H73.999V32.5625L75.1193 34.5V50H75.6795V35.4375L76.8621 37.375V50H77.4222V38.3125L78.5426 40.25V50H79.165V41.1875L80.2853 43.125V50H80.8455V44.0625L82.0281 46V50H82.5882V46.9375L83.7086 48.875V50H84.2687V0.0624992H83.7086V29L82.5882 27.0625V0.0624992H82.0281V26.125L80.8455 24.1875V0.0624992H80.2853V23.25L79.165 21.3125V0.0624992H78.5426V20.3125L77.4222 18.4375V0.0624992H76.8621V17.4375L75.6795 15.5625V0.0624992H75.1193V14.5625L73.999 12.6875V0.0624992H73.4388V11.6875L72.2562 9.75V0.0624992H71.696V8.8125L70.5757 6.875V0.0624992H69.9533V5.9375L68.833 4V0.0624992H68.2728V3.0625L67.0902 1.125V0H66.53L54.5175 0.0624992V50Z" fill="white"/>
<path d="M124.066 0L91.4521 0.0624992V10.625L124.066 10.5625V0ZM112.054 19.75L91.4521 19.8125V30.25L112.116 30.1875L112.054 19.75ZM91.4521 39.6875V50L125 49.9375V39.625L91.4521 39.6875ZM91.4521 38V38.5625H112.054V38H91.4521ZM91.4521 36.25V36.875H112.054V36.25H91.4521ZM91.4521 34.5625V35.125H112.054V34.5625H91.4521ZM91.4521 32.875V33.4375H112.054V32.875H91.4521ZM91.4521 31.1875V31.75H112.054V31.1875H91.4521ZM91.4521 18.4375V19.0625H112.054V18.4375H91.4521ZM91.4521 16.75V17.3125H112.054V16.75H91.4521ZM91.4521 15.0625V15.625H112.054V15.0625H91.4521ZM91.4521 13.375V13.9375H112.054V13.375H91.4521ZM91.4521 11.6875V12.25H112.054V11.6875H91.4521Z" fill="white"/>
<path d="M25.326 49.5131C32.213 49.3924 38.0419 46.894 42.8126 42.018C47.5827 37.1003 49.9084 31.2254 49.7896 24.3931C49.6708 17.5608 47.1428 11.7917 42.2054 7.08585C37.2674 2.33833 31.3548 0.0249299 24.4679 0.145642C17.5809 0.266355 11.7524 2.78555 6.98236 7.70323C2.21157 12.5792 -0.114437 18.4334 0.00432705 25.2657C0.0962967 30.5566 1.79904 35.4025 5.11257 39.8034C7.44871 42.8879 10.3537 45.2749 13.8276 46.9642C17.4274 48.7348 21.2602 49.5844 25.326 49.5131ZM24.4709 39.7141L24.4568 38.9017L20.474 38.9715C19.597 38.6535 18.8022 38.2924 18.0896 37.8882L24.4373 37.7769L24.4275 37.2145L17.1464 37.3421C16.6427 37.0176 16.1384 36.6513 15.6333 36.2435L24.4079 36.0897L24.3982 35.5273L15.0012 35.692C14.8746 35.5692 14.7053 35.3846 14.4936 35.1383C14.2403 34.8927 14.0503 34.7085 13.9237 34.5857L24.3786 34.4024L24.3677 33.7775L13.4772 33.9684C13.2225 33.6395 12.9671 33.2689 12.7109 32.8567L24.3482 32.6527L24.3384 32.0903L12.3277 32.3008L11.7481 31.1858L24.3189 30.9654L24.3091 30.403L11.4894 30.6277L11.0964 29.5095L24.2895 29.2782L24.2787 28.6533L10.8989 28.8878C10.8116 28.6393 10.7221 28.2658 10.6304 27.7674L24.2591 27.5285L24.2493 26.9661L10.4962 27.2071C10.4525 27.0829 10.4285 26.8958 10.4242 26.6458C10.3783 26.3966 10.3543 26.2095 10.3521 26.0845L24.2298 25.8412L24.22 25.2788L10.3424 25.5221L10.3217 24.3347L24.1994 24.0915L24.1896 23.5291L10.3742 23.7712C10.3698 23.5213 10.4048 23.1456 10.4791 22.6442L24.17 22.4043L24.1603 21.8418L10.5316 22.0807C10.5709 21.955 10.6298 21.7664 10.7085 21.515C10.7456 21.2643 10.7838 21.0761 10.8232 20.9504L24.1407 20.717L24.1299 20.0921L10.9368 20.3233C10.9761 20.1976 11.0558 20.0087 11.1759 19.7566C11.2538 19.4635 11.3332 19.2537 11.414 19.1273L24.1092 18.9048L24.0994 18.3424L11.6531 18.5605L12.1937 17.4259L24.0799 17.2175L24.0701 16.6551L12.5573 16.8569C12.7982 16.3943 13.061 15.9938 13.3456 15.6554L24.0495 15.4678L24.0397 14.9054L13.8337 15.0843C14.0368 14.8307 14.3829 14.4496 14.8721 13.9409L24.0201 13.7806L24.0104 13.2182L15.5469 13.3665C16.0782 12.8988 16.5903 12.5147 17.0831 12.2144L23.9908 12.0933L23.9799 11.4684L18.068 11.572C18.932 11.1402 19.9004 10.7481 20.9733 10.3959L23.9604 10.3436L23.9517 9.84366L24.7607 9.82948C28.8265 9.75822 32.3368 11.1552 35.2917 14.0206C38.205 16.8866 39.6975 20.3818 39.7692 24.5062C39.8409 28.6306 38.4708 32.176 35.6588 35.1424C32.8054 38.1095 29.3457 39.6287 25.2799 39.6999L24.4709 39.7141Z" fill="white"/>
</svg>
</file>

<file path="shared/ensure.ts">
import { isKinds } from "./filter";

const getErrMsg = (err: string | (() => string)) => (typeof err === "string" ? err : err());

export const ensureNotUndefined = <T>(
  obj: T | undefined,
  err: string | (() => string) = `variable was undefined when it shouldnt have been.`,
): T => {
  if (obj === undefined) throw new Error(getErrMsg(err));
  return obj;
};

export const ensureNotNull = <T>(
  obj: T | null,
  err: string | (() => string) = `variable was null when it shouldnt have been.`,
): T => {
  if (obj === null) throw new Error(getErrMsg(err));
  return obj;
};

export const ensure = <T>(
  obj: Nullable<T>,
  err: string | (() => string) = `variable was undefined or null when it shouldnt have been.`,
): T => {
  obj = ensureNotUndefined(obj, err);
  obj = ensureNotNull(obj, err);
  return obj;
};

export const createEnsurer =
  <TVal, TArgs>(
    fn: (...args: TArgs[]) => TVal | undefined | null,
    err = `variable was undefined or null when it shouldnt have been.`,
  ) =>
  (...args: TArgs[]) =>
    ensure(fn(...args), err);

export const ensureFP =
  (err = `variable was undefined or null when it shouldnt have been.`) =>
  <T>(obj: Nullable<T>): T => {
    obj = ensureNotUndefined(obj, err);
    obj = ensureNotNull(obj, err);
    return obj;
  };

export const ensureNotUndefinedFP =
  (err = `variable was undefined when it shouldnt have been.`) =>
  <T>(obj: T | undefined): T => {
    if (obj === undefined) throw new Error(err);
    return obj;
  };

export const ensureKind = <
  TKindable extends {
    kind: string;
  },
  TKind extends TKindable["kind"],
>(
  kind: TKind,
  val: TKindable,
): Extract<TKindable, { kind: TKind }> => {
  if (!isKinds(kind)(val)) throw new Error(`Expected ${kind} but got ${val.kind}`);
  return val as any;
};

export type Nullable<T> = T | undefined | null;
</file>

<file path="shared/filter.ts">
export const isNotNullOrUndefined = <T>(item: T | null | undefined): item is T => {
  if (item === null) return false;
  if (item === undefined) return false;
  return true;
};

export const isNotFalsey = <T>(item: T | null | undefined): item is T => {
  return Boolean(item);
};

export const isFalse = (item: boolean): item is false => item == false;

export const isTrue = (item: boolean): item is true => item == true;

export const isKinds =
  <
    TKindable extends {
      kind: string;
    },
    TKind extends TKindable["kind"],
  >(
    ...kinds: TKind[]
  ) =>
  (item: TKindable): item is Extract<TKindable, { kind: TKind }> =>
    kinds.includes(item.kind as any);

export const isKind =
  <
    TKindable extends {
      kind: string;
    },
    TKind extends TKindable["kind"],
  >(
    kind: TKind,
  ) =>
  (item: TKindable): item is Extract<TKindable, { kind: TKind }> =>
    kind == item.kind;
</file>

<file path="shared/predefinedAgents.ts">
import { AgentToolName } from "./tools";

export type PredefinedAgent = {
  name: string;
  description: string;
  personality: string;
  tools: AgentToolName[];
};

export const predefinedAgents: PredefinedAgent[] = [
  {
    name: "Research Navigator",
    description:
      "Expert at finding information and conducting thorough research on any topic",
    personality:
      "Methodical, curious, and detail-oriented with a drive to uncover accurate information",
    tools: ["webSearch"],
  },
  {
    name: "Content Crafter",
    description:
      "Skilled writer that can generate high-quality content in various formats and styles",
    personality:
      "Creative, adaptable, and eloquent with a flair for engaging writing",
    tools: ["webSearch"],
  },
  {
    name: "Data Decoder",
    description:
      "Analyzes and interprets complex data to deliver actionable insights",
    personality:
      "Analytical, precise, and objective with a talent for explaining complex concepts simply",
    tools: ["webSearch"],
  },
  {
    name: "Task Titan",
    description:
      "Organizes tasks, tracks progress, and helps manage projects efficiently",
    personality:
      "Organized, proactive, and efficient with strong prioritization skills",
    tools: [],
  },
  {
    name: "Code Companion",
    description:
      "Assists with coding problems, debugging, and software development tasks",
    personality:
      "Logical, systematic, and patient with attention to technical detail",
    tools: ["webSearch"],
  },
  {
    name: "Idea Igniter",
    description:
      "Generates creative ideas and facilitates brainstorming sessions",
    personality:
      "Imaginative, enthusiastic, and open-minded with a knack for unexpected connections",
    tools: ["webSearch"],
  },
  {
    name: "Meeting Maestro",
    description:
      "Schedules, facilitates, and summarizes meetings to maximize productivity",
    personality:
      "Attentive, organized, and concise with excellent note-taking abilities",
    tools: [],
  },
  {
    name: "Document Doctor",
    description:
      "Expertly handles document processing, organization, and analysis",
    personality:
      "Meticulous, structured, and thorough with strong organizational skills",
    tools: ["webSearch"],
  },
  {
    name: "Social Spark",
    description:
      "Creates engaging social media content and manages online presence",
    personality:
      "Trendy, engaging, and witty with an understanding of social media dynamics",
    tools: ["webSearch"],
  },
  {
    name: "Support Sage",
    description:
      "Provides helpful and patient customer support for common issues",
    personality:
      "Empathetic, patient, and clear with a focus on user satisfaction",
    tools: [],
  },
  {
    name: "Learning Lens",
    description:
      "Creates personalized learning experiences and educational content",
    personality:
      "Encouraging, clear, and adaptable with a passion for teaching",
    tools: ["webSearch"],
  },
  {
    name: "Financial Forecast",
    description:
      "Provides financial insights, budgeting advice, and economic analysis",
    personality:
      "Prudent, precise, and trustworthy with a focus on financial well-being",
    tools: ["webSearch"],
  },
  {
    name: "Legal Lighthouse",
    description:
      "Offers general legal information and guidance (not legal advice)",
    personality:
      "Careful, thorough, and balanced with attention to detail and clarity",
    tools: ["webSearch"],
  },
  {
    name: "Wellness Whisperer",
    description:
      "Provides health and wellness information and motivational support",
    personality:
      "Supportive, balanced, and encouraging with a holistic approach",
    tools: [],
  },
  {
    name: "Travel Tracker",
    description:
      "Plans trips, suggests destinations, and provides travel recommendations",
    personality:
      "Adventurous, knowledgeable, and practical with global awareness",
    tools: ["webSearch"],
  },
  {
    name: "Shopping Scout",
    description:
      "Finds products and services based on specific needs and preferences",
    personality:
      "Helpful, resourceful, and discerning with attention to quality and value",
    tools: ["webSearch"],
  },
  {
    name: "Design Director",
    description:
      "Provides design feedback, suggestions, and creative direction",
    personality:
      "Visually astute, honest, and constructive with an eye for aesthetics",
    tools: ["webSearch"],
  },
  {
    name: "Translation Trailblazer",
    description:
      "Translates content between languages and explains cultural nuances",
    personality:
      "Culturally sensitive, precise, and knowledgeable with linguistic expertise",
    tools: ["webSearch"],
  },
  {
    name: "News Nexus",
    description:
      "Summarizes news, tracks trends, and provides balanced information",
    personality:
      "Objective, concise, and up-to-date with a focus on relevant information",
    tools: ["webSearch"],
  },
  {
    name: "Entertainment Explorer",
    description:
      "Recommends movies, books, music, and other entertainment options",
    personality:
      "Enthusiastic, insightful, and diverse with broad cultural knowledge",
    tools: ["webSearch"],
  },
];
</file>

<file path="src/components/authenticated/chat/BaseMention.tsx">
import * as React from "react";

interface BaseMentionProps {
  display: string;
  isInUserMessage?: boolean;
  onClick?: () => void;
  avatar: React.ReactNode;
}

export const BaseMention: React.FC<BaseMentionProps> = ({
  display,
  isInUserMessage,
  onClick,
  avatar,
}) => {
  return (
    <span
      onClick={onClick}
      className={`
        inline-flex items-center gap-1 px-1 py-0.5 rounded text-sm 
        transition-colors duration-200
        ${onClick ? "cursor-pointer" : ""}
        align-baseline
        ${
          isInUserMessage
            ? "bg-primary-foreground/20 hover:bg-primary-foreground/30"
            : "bg-accent/50 hover:bg-accent/60"
        }
      `}
    >
      {avatar}
      <span className="leading-none">{display}</span>
    </span>
  );
};
</file>

<file path="src/components/authenticated/conversations/ConversationItem.tsx">
import * as React from "react";

interface ConversationItemProps {
  id: string;
  title: string;
  lastMessageTime: number;
  isSelected: boolean;
  onSelect: (id: string) => void;
}

export const ConversationItem: React.FC<ConversationItemProps> = ({
  id,
  title,
  lastMessageTime,
  isSelected,
  onSelect,
}) => (
  <div
    onClick={() => onSelect(id)}
    className={`p-4 cursor-pointer hover:bg-accent ${
      isSelected ? "bg-accent" : ""
    }`}
  >
    <div className="font-medium text-primary-foreground">{title}</div>
    <div className="text-sm text-muted-foreground/80 truncate">
      {new Date(lastMessageTime).toLocaleTimeString()}
    </div>
  </div>
);
</file>

<file path="src/components/misc/errors.ts">
import { useCallback } from "react";
import { toast } from "sonner";

export const useApiErrorHandler = () => {
  return useCallback((e: any) => {
    console.error("APIError: ", e);
    toast.error(`${e}`);
  }, []);
};
</file>

<file path="src/components/ui/avatar.tsx">
import * as React from "react";
import * as AvatarPrimitive from "@radix-ui/react-avatar";

import { cn } from "@/lib/utils";

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className,
      )}
      {...props}
    />
  );
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  );
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className,
      )}
      {...props}
    />
  );
}

export { Avatar, AvatarImage, AvatarFallback };
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/70",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src/components/ui/dropdown-menu.tsx">
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="src/components/ui/tooltip.tsx">
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/components/unauthenticated/UnauthenticatedContent.tsx">
import * as React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";
import { Button } from "../ui/button";
import { ChevronRight, ArrowLeft, Mail } from "lucide-react";
import { SignInWithGithub } from "./SignInWithGithub";
import { SignInWithPassword } from "./SignInWithPassword";

export function UnauthenticatedContent() {
  const [showPasswordSignIn, setShowPasswordSignIn] = React.useState(false);
  const [authMode, setAuthMode] = React.useState<"signIn" | "signUp">("signIn");

  return (
    <main className="min-h-screen flex flex-col items-center justify-center p-8">
      <div className="mb-8 flex flex-col items-center">
        <img
          src="/logo.svg"
          alt="ONE logo"
          className="w-72 h-auto mb-2"
        />
      </div>
      <Card className="w-full max-w-xs relative overflow-hidden shadow-md border-neutral-200 p-0">
        <div
          className="flex transition-transform duration-300 ease-in-out"
          style={{
            transform: showPasswordSignIn
              ? "translateX(-100%)"
              : "translateX(0)",
          }}
        >
          {/* First page - GitHub sign-in */}
          <div className="min-w-full shrink-0">
            <CardContent className="flex flex-col items-center gap-4 p-6">
              <SignInWithGithub />
              <div className="flex items-center gap-4 w-full my-2">
                <div className="h-px bg-neutral-300 flex-1" />
                <span className="text-neutral-700 text-sm font-medium px-2">
                  or
                </span>
                <div className="h-px bg-neutral-300 flex-1" />
              </div>
              <Button
                variant="outline"
                className="w-full h-10"
                onClick={() => setShowPasswordSignIn(true)}
              >
                <Mail className="mr-2 h-4 w-4" />
                Continue with Email
                <ChevronRight className="ml-auto h-4 w-4" />
              </Button>
            </CardContent>
          </div>

          {/* Second page - Password sign-in */}
          {showPasswordSignIn ? (
            <div className="min-w-full shrink-0">
              <CardHeader className="relative pb-0">
                <Button
                  variant="ghost"
                  size="icon"
                  className="absolute left-4 top-4"
                  onClick={() => setShowPasswordSignIn(false)}
                >
                  <ArrowLeft className="h-4 w-4" />
                </Button>
                <CardTitle className="text-xl text-center mt-2 pt-4">
                  {authMode === "signIn"
                    ? "Sign in with Email"
                    : "Create an Account"}
                </CardTitle>
              </CardHeader>
              <CardContent className="p-6">
                <SignInWithPassword onModeChange={setAuthMode} />
              </CardContent>
            </div>
          ) : null}
        </div>
      </Card>
    </main>
  );
}
</file>

<file path="src/App.tsx">
import * as React from "react";
import { Authenticated, Unauthenticated } from "convex/react";
import { AuthenticatedContent } from "./components/authenticated/AuthenticatedContent";
import { UnauthenticatedContent } from "./components/unauthenticated/UnauthenticatedContent";
import { toast, Toaster } from "sonner";
import { RouteProvider } from "./routes";
import { ConvexQueryCacheProvider } from "convex-helpers/react/cache";

export default function App() {
  return (
    <RouteProvider>
      <ConvexQueryCacheProvider>
        <div className="min-h-screen bg-background">
          <Authenticated>
            <AuthenticatedContent />
          </Authenticated>
          <Unauthenticated>
            <UnauthenticatedContent />
          </Unauthenticated>
        </div>
        <Toaster />
      </ConvexQueryCacheProvider>
    </RouteProvider>
  );
}
</file>

<file path=".cursor/rules/project.mdc">
---
description: 
globs: 
alwaysApply: true
---
This is a shadcnui project, so please look at the components in /src/components/ui before creating your own for something or if there is an existing shadcn component that you know of and think the project needs to be installed please ask me to install it.

When calling convex mutations from the React code you should use the "useApiErrorHandler" from "src/misc/error" and then you should catch errors, for example: 

```ts
createAgent()
    .then((agentId) => routes.agent({ agentId }).push())
    .catch(onApiError)
```

Simmilarly if the logic is simple you should refreain from using try catch finally and instead just use the funcional approach. 

So instead of this:

```ts
try {
 await deleteAgent({ agentId });
 routes.home().push();
}
catch(error) {
    onApiError(error);
}
finally {
    tidyUp();
}

```

You should do this as it uses less lines and is easier to read:

```ts
deleteAgent({ agentId })
    .then(() => routes.home().push())
    .catch(onApiError)
    .finally(tidyUp)
```
</file>

<file path="convex/conversationMessages/internalMutations.ts">
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";
import * as Messages from "./model";
import * as Agents from "../agents/model";
import * as ConversationParticipants from "../conversationParticipants/model";

export const sendFromTriageAgent = internalMutation({
  args: {
    conversationId: v.id("conversations"),
    content: v.string(),
  },
  returns: v.id("conversationMessages"),
  handler: async (ctx, args) => {
    const triageAgent = await Agents.getTriageAgent(ctx.db);

    const triageAgentParticipant =
      await ConversationParticipants.getParticipantByConversationIdAndIdentifier(
        ctx.db,
        {
          conversationId: args.conversationId,
          identifier: {
            kind: "agent",
            agentId: triageAgent._id,
          },
        },
      );

    const messageId = await Messages.addMessageToConversationFromAgent(ctx, {
      conversationId: args.conversationId,
      content: args.content,
      agentId: triageAgent._id,
      authorParticipantId: triageAgentParticipant._id,
    });

    return messageId;
  },
});

export const sendFromAgent = internalMutation({
  args: {
    conversationId: v.id("conversations"),
    agentId: v.id("agents"),
    content: v.string(),
    authorParticipantId: v.id("conversationParticipants"),
  },
  returns: v.id("conversationMessages"),
  handler: async (ctx, args) => {
    return await Messages.addMessageToConversationFromAgent(ctx, args);
  },
});

export const sendSystemMessage = internalMutation({
  args: {
    conversationId: v.id("conversations"),
    content: v.string(),
    meta: v.optional(v.any()),
  },
  returns: v.id("conversationMessages"),
  handler: async (ctx, args) => {
    return await Messages.addMessageToConversationFromSystem(ctx.db, args);
  },
});
</file>

<file path="convex/users/model.ts">
import { getAuthUserId } from "@convex-dev/auth/server";
import { DatabaseReader, QueryCtx } from "../_generated/server";
import { Id } from "../_generated/dataModel";

export const find = async (
  db: DatabaseReader,
  { userId }: { userId: Id<"users"> },
) => {
  return await db.get(userId);
};

export const get = async (
  db: DatabaseReader,
  { userId }: { userId: Id<"users"> },
) => {
  const user = await find(db, { userId });
  if (!user) throw new Error(`User not found ${userId}`);
  return user;
};

export const getMyId = async (ctx: QueryCtx) => {
  const userId = await getAuthUserId(ctx);
  if (!userId) throw new Error("Not authenticated");
  return userId;
};

export const getMe = async (ctx: QueryCtx) => {
  const userId = await getMyId(ctx);
  const user = await ctx.db.get(userId);
  if (!user) throw new Error("User not found");
  return user;
};
</file>

<file path="convex/README.md">
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// functions.js
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// functions.js
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get(id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.
</file>

<file path="convex/tsconfig.json">
{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": [
    "./**/*",
    "../shared/mentions.test.ts",
    "../shared/predefinedAgents.ts"
  ],
  "exclude": ["./_generated"]
}
</file>

<file path="shared/mentions.test.ts">
import { test, expect, describe } from "vitest";
import { Id } from "../convex/_generated/dataModel";
import {
  parseMentionsFromMessageContent,
  splitMessageContent,
  createMentionString,
} from "./mentions";

describe("parseReferencesFromMessageContent", () => {
  test("should return empty array when no references are present", () => {
    const content = "Hello world, this is a message with no references";
    const result = parseMentionsFromMessageContent(content);
    expect(result).toEqual([]);
  });

  test("should parse a single agent reference", () => {
    const agentId = "abc123" as Id<"agents">;
    const content = `Hello @[Agent Smith](agent:${agentId}), how are you?`;

    const result = parseMentionsFromMessageContent(content);

    expect(result).toEqual([
      {
        kind: "agent",
        agentId,
        display: "Agent Smith",
      },
    ]);
  });

  test("should parse multiple agent references", () => {
    const agentId1 = "abc123" as Id<"agents">;
    const agentId2 = "def456" as Id<"agents">;
    const content = `Hello @[Agent Smith](agent:${agentId1}), can you talk to @[Agent Johnson](agent:${agentId2})?`;

    const result = parseMentionsFromMessageContent(content);

    expect(result).toEqual([
      {
        kind: "agent",
        agentId: agentId1,
        display: "Agent Smith",
      },
      {
        kind: "agent",
        agentId: agentId2,
        display: "Agent Johnson",
      },
    ]);
  });

  test("should handle references with special characters in name", () => {
    const agentId = "abc123" as Id<"agents">;
    const content = `Hello @[Agent Smith-Jones (AI)](agent:${agentId})`;

    const result = parseMentionsFromMessageContent(content);

    expect(result).toEqual([
      {
        kind: "agent",
        agentId,
        display: "Agent Smith-Jones (AI)",
      },
    ]);
  });

  test("should handle references at beginning, middle and end of content", () => {
    const agentId1 = "abc123" as Id<"agents">;
    const agentId2 = "def456" as Id<"agents">;
    const agentId3 = "ghi789" as Id<"agents">;

    const content = `@[First](agent:${agentId1}) is at the beginning, @[Second](agent:${agentId2}) is in the middle, and @[Third](agent:${agentId3})`;

    const result = parseMentionsFromMessageContent(content);

    expect(result).toEqual([
      { kind: "agent", agentId: agentId1, display: "First" },
      { kind: "agent", agentId: agentId2, display: "Second" },
      { kind: "agent", agentId: agentId3, display: "Third" },
    ]);
  });

  test("should parse a single user reference", () => {
    const userId = "xyz789" as Id<"users">;
    const content = `Hello @[John](user:${userId}), how are you?`;

    const result = parseMentionsFromMessageContent(content);

    expect(result).toEqual([
      {
        kind: "user",
        userId,
        display: "John",
      },
    ]);
  });

  test("should parse mixed agent and user references", () => {
    const agentId = "abc123" as Id<"agents">;
    const userId = "xyz789" as Id<"users">;
    const content = `@[Agent Smith](agent:${agentId}) please help @[John](user:${userId}) with their request`;

    const result = parseMentionsFromMessageContent(content);

    expect(result).toEqual([
      {
        kind: "agent",
        agentId,
        display: "Agent Smith",
      },
      {
        kind: "user",
        userId,
        display: "John",
      },
    ]);
  });
});

describe("splitMessageContent", () => {
  test("should return single text part when no mentions exist", () => {
    const content = "Hello world, this is a message with no mentions";
    const result = splitMessageContent(content);
    expect(result).toEqual([
      {
        type: "text",
        content: "Hello world, this is a message with no mentions",
      },
    ]);
  });

  test("should split content with a single mention", () => {
    const agentId = "abc123" as Id<"agents">;
    const content = `Hello @[Agent Smith](agent:${agentId}), how are you?`;

    const result = splitMessageContent(content);

    expect(result).toEqual([
      {
        type: "text",
        content: "Hello ",
      },
      {
        type: "mention",
        content: `@[Agent Smith](agent:${agentId})`,
        reference: {
          kind: "agent",
          agentId,
          display: "Agent Smith",
        },
      },
      {
        type: "text",
        content: ", how are you?",
      },
    ]);
  });

  test("should handle multiple mentions with text between", () => {
    const agentId = "abc123" as Id<"agents">;
    const userId = "xyz789" as Id<"users">;
    const content = `@[Agent Smith](agent:${agentId}) please help @[John](user:${userId}) with their request`;

    const result = splitMessageContent(content);

    expect(result).toEqual([
      {
        type: "mention",
        content: `@[Agent Smith](agent:${agentId})`,
        reference: {
          kind: "agent",
          agentId,
          display: "Agent Smith",
        },
      },
      {
        type: "text",
        content: " please help ",
      },
      {
        type: "mention",
        content: `@[John](user:${userId})`,
        reference: {
          kind: "user",
          userId,
          display: "John",
        },
      },
      {
        type: "text",
        content: " with their request",
      },
    ]);
  });

  test("should handle adjacent mentions without text between", () => {
    const agentId1 = "abc123" as Id<"agents">;
    const agentId2 = "def456" as Id<"agents">;
    const content = `@[Agent1](agent:${agentId1})@[Agent2](agent:${agentId2})`;

    const result = splitMessageContent(content);

    expect(result).toEqual([
      {
        type: "mention",
        content: `@[Agent1](agent:${agentId1})`,
        reference: {
          kind: "agent",
          agentId: agentId1,
          display: "Agent1",
        },
      },
      {
        type: "mention",
        content: `@[Agent2](agent:${agentId2})`,
        reference: {
          kind: "agent",
          agentId: agentId2,
          display: "Agent2",
        },
      },
    ]);
  });
});

describe("createMentionString", () => {
  test("should create agent mention string", () => {
    const agentId = "abc123" as Id<"agents">;
    const reference = {
      kind: "agent" as const,
      agentId,
      name: "Agent Smith",
    };

    const result = createMentionString(reference);
    expect(result).toBe(`@[Agent Smith](agent:${agentId})`);

    // Verify the generated string can be parsed back correctly
    const parsed = parseMentionsFromMessageContent(result);
    expect(parsed).toEqual([
      {
        kind: "agent",
        agentId,
        display: "Agent Smith",
      },
    ]);
  });

  test("should create user mention string", () => {
    const userId = "xyz789" as Id<"users">;
    const reference = {
      kind: "user" as const,
      userId,
      name: "John Doe",
    };

    const result = createMentionString(reference);
    expect(result).toBe(`@[John Doe](user:${userId})`);

    // Verify the generated string can be parsed back correctly
    const parsed = parseMentionsFromMessageContent(result);
    expect(parsed).toEqual([
      {
        kind: "user",
        userId,
        display: "John Doe",
      },
    ]);
  });

  test("should handle special characters in names", () => {
    const agentId = "abc123" as Id<"agents">;
    const reference = {
      kind: "agent" as const,
      agentId,
      name: "Agent Smith-Jones (AI)",
    };

    const result = createMentionString(reference);
    expect(result).toBe(`@[Agent Smith-Jones (AI)](agent:${agentId})`);

    // Verify the generated string can be parsed back correctly
    const parsed = parseMentionsFromMessageContent(result);
    expect(parsed).toEqual([
      {
        kind: "agent",
        agentId,
        display: "Agent Smith-Jones (AI)",
      },
    ]);
  });
});
</file>

<file path="shared/mentions.ts">
import { Id } from "../convex/_generated/dataModel";
import { MessageReference } from "./misc";

export type MessagePart =
  | { type: "text"; content: string }
  | { type: "mention"; content: string; reference: MessageReference };

// Shared regex pattern for mention format: @[name](kind:id)
const MENTION_REGEX = /@\[([^\]]+)\]\(([^:]+):([^)]+)\)/g;

/**
 * Creates a mention string for a user or agent.
 *
 * @param reference - The reference object containing user or agent details
 * @returns A string in the format "@[name](kind:id)"
 */
export const createMentionString = (
  reference:
    | { kind: "user"; userId: Id<"users">; name: string }
    | { kind: "agent"; agentId: Id<"agents">; name: string },
): string => {
  if (reference.kind === "agent") {
    return `@[${reference.name}](agent:${reference.agentId})`;
  } else {
    return `@[${reference.name}](user:${reference.userId})`;
  }
};

/**
 * Splits message content into an array of text and mention parts.
 * Text parts contain regular text content, while mention parts contain the reference data.
 *
 * @param content - The message content to split
 * @returns Array of message parts (text or mention)
 */
export const splitMessageContent = (content: string): MessagePart[] => {
  const mentions = parseMentionsFromMessageContent(content);
  const parts: MessagePart[] = [];
  let lastIndex = 0;
  let mentionIndex = 0;

  let match;
  // Reset the regex to start from the beginning
  MENTION_REGEX.lastIndex = 0;

  while ((match = MENTION_REGEX.exec(content)) !== null) {
    if (match.index > lastIndex) {
      parts.push({
        type: "text",
        content: content.slice(lastIndex, match.index),
      });
    }

    parts.push({
      type: "mention",
      content: match[0],
      reference: mentions[mentionIndex++],
    });

    lastIndex = match.index + match[0].length;
  }

  if (lastIndex < content.length) {
    parts.push({
      type: "text",
      content: content.slice(lastIndex),
    });
  }

  return parts;
};

/**
 * Parses message content to extract references to entities like users or agents.
 *
 * References are formatted as: @[name](kind:id)
 * Example: "Hello @[Mike](agent:abc1234)" references an agent with ID abc1234
 * Example: "Hello @[John](user:xyz789)" references a user with ID xyz789
 *
 * @param content - The message content to parse
 * @returns Array of references found in the message content
 */
export const parseMentionsFromMessageContent = (
  content: string,
): MessageReference[] => {
  const references: MessageReference[] = [];

  let match;
  // Reset the regex to start from the beginning
  MENTION_REGEX.lastIndex = 0;

  while ((match = MENTION_REGEX.exec(content)) !== null) {
    const [_, name, kind, id] = match;

    if (kind === "agent") {
      references.push({
        kind: "agent",
        agentId: id as Id<"agents">,
        display: name,
      });
    } else if (kind === "user") {
      references.push({
        kind: "user",
        userId: id as Id<"users">,
        display: name,
      });
    }
  }

  return references;
};
</file>

<file path="src/components/authenticated/chat/ChatContext.tsx">
import React, { createContext, useContext, useState, ReactNode } from "react";

interface ChatContextType {
  replyToMention: string | null;
  setReplyToMention: (mention: string | null) => void;
  shouldFocusInput: boolean;
  setShouldFocusInput: (focus: boolean) => void;
}

const ChatContext = createContext<ChatContextType | undefined>(undefined);

export function useChatContext() {
  const context = useContext(ChatContext);
  if (context === undefined) {
    throw new Error("useChatContext must be used within a ChatProvider");
  }
  return context;
}

interface ChatProviderProps {
  children: ReactNode;
}

export function ChatProvider({ children }: ChatProviderProps) {
  const [replyToMention, setReplyToMention] = useState<string | null>(null);
  const [shouldFocusInput, setShouldFocusInput] = useState(false);

  return (
    <ChatContext.Provider
      value={{
        replyToMention,
        setReplyToMention,
        shouldFocusInput,
        setShouldFocusInput,
      }}
    >
      {children}
    </ChatContext.Provider>
  );
}
</file>

<file path="src/components/authenticated/chat/ThinkingIndicator.tsx">
import * as React from "react";
import { useQuery } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";
import { Avatar, AvatarImage, AvatarFallback } from "../../ui/avatar";
import { Loader2 } from "lucide-react";

interface ThinkingIndicatorProps {
  conversationId: Id<"conversations">;
}

export const ThinkingIndicator: React.FC<ThinkingIndicatorProps> = ({
  conversationId,
}) => {
  const thinkingParticipants = useQuery(
    api.conversationParticipants.queries.listThinkingParticipants,
    {
      conversationId,
    },
  );

  if (!thinkingParticipants?.length) return null;

  return (
    <>
      {thinkingParticipants.map((participant) => (
        <div key={participant.id} className="flex items-start gap-3">
          <Avatar className="mt-1">
            <AvatarImage src={participant.avatarUrl} />
            <AvatarFallback>{participant.name[0]}</AvatarFallback>
          </Avatar>
          <div className="max-w-[70%] rounded-lg p-3 bg-muted">
            <div className="flex items-center gap-2 text-sm text-muted-foreground">
              <Loader2 className="h-3 w-3 animate-spin" />
              <span>{participant.name} is thinking</span>
            </div>
          </div>
        </div>
      ))}
    </>
  );
};
</file>

<file path="src/components/authenticated/sidebar/Sidebar.tsx">
import * as React from "react";
import { ConversationList } from "./ConversationList";
import { AgentList } from "./AgentList";
import { Button } from "../../ui/button";
import { UserProfile } from "@/components/authenticated/conversations/UserProfile";

type Tab = "conversations" | "agents";

export const Sidebar = () => {
  const [activeTab, setActiveTab] = React.useState<Tab>("conversations");

  return (
    <div className="flex flex-col h-full border-r">
      <div className="h-24 border-b border-border relative overflow-hidden">
        <img
          src="/logo.svg"
          alt="ONE"
          className="absolute -right-0 -top-2 h-32 object-cover p-5"
        />
        <div className="absolute inset-x-0 bottom-0 h-12 bg-gradient-to-t from-card to-transparent" />
      </div>
      <div className="flex border-b">
        <Button
          variant={activeTab === "conversations" ? "default" : "ghost"}
          className="flex-1 rounded-none text-primary-foreground"
          onClick={() => setActiveTab("conversations")}
        >
          Conversations
        </Button>
        <Button
          variant={activeTab === "agents" ? "default" : "ghost"}
          className="flex-1 rounded-none text-primary-foreground"
          onClick={() => setActiveTab("agents")}
        >
          Agents
        </Button>
      </div>
      <div className="flex-1 min-h-0 overflow-hidden flex flex-col">
        <div className="flex-1 overflow-y-auto">
          {activeTab === "conversations" ? <ConversationList /> : <AgentList />}
        </div>
      </div>
      <UserProfile />
    </div>
  );
};
</file>

<file path="src/components/misc/hooks.ts">
import * as React from "react";
import {
  formatDistanceToNow,
  differenceInSeconds,
  differenceInMinutes,
  differenceInHours,
} from "date-fns";

/**
 * Hook that returns a dynamically updating relative time string (e.g. "2 minutes ago")
 * Updates more frequently for recent timestamps and less frequently for older ones.
 */
export const useTimeAgo = (timestamp: number) => {
  const [timeAgo, setTimeAgo] = React.useState(() =>
    formatDistanceToNow(new Date(timestamp), { addSuffix: true }),
  );

  React.useEffect(() => {
    const date = new Date(timestamp);

    const getUpdateInterval = () => {
      const secondsOld = differenceInSeconds(new Date(), date);
      const minutesOld = differenceInMinutes(new Date(), date);
      const hoursOld = differenceInHours(new Date(), date);

      if (secondsOld < 60) return 1000; // Update every second
      if (minutesOld < 60) return 60000; // Update every minute
      if (hoursOld < 24) return 300000; // Update every 5 minutes
      return 3600000; // Update every hour for older messages
    };

    const updateTimeAgo = () => {
      setTimeAgo(formatDistanceToNow(date, { addSuffix: true }));
    };

    const interval = setInterval(() => {
      updateTimeAgo();
      // Dynamically adjust the interval
      clearInterval(interval);
      const newInterval = setInterval(updateTimeAgo, getUpdateInterval());
      return () => clearInterval(newInterval);
    }, getUpdateInterval());

    return () => clearInterval(interval);
  }, [timestamp]);

  return timeAgo;
};
</file>

<file path="src/components/ui/editable-text.tsx">
import * as React from "react";
import { Button } from "./button";
import { Textarea } from "./textarea";
import { cn } from "@/lib/utils";
import { useApiErrorHandler } from "@/components/misc/errors";

export interface EditableTextHandle {
  startEditing: () => void;
}

interface EditableTextProps {
  value: string;
  onSave: (value: string) => Promise<void>;
  className?: string;
  textClassName?: string;
  editRef?: React.RefObject<EditableTextHandle | null>;
}

export const EditableText: React.FC<EditableTextProps> = ({
  value,
  onSave,
  className,
  textClassName,
  editRef,
}) => {
  const [isEditing, setIsEditing] = React.useState(false);
  const [editValue, setEditValue] = React.useState(value);
  const [isSaving, setIsSaving] = React.useState(false);
  const onApiError = useApiErrorHandler();

  React.useEffect(() => {
    setEditValue(value);
  }, [value]);

  React.useImperativeHandle(
    editRef,
    () => ({
      startEditing: () => setIsEditing(true),
    }),
    [],
  );

  if (isEditing)
    return (
      <div className={cn("space-y-2", className)}>
        <Textarea
          value={editValue}
          onChange={(e) => setEditValue(e.target.value)}
          className="min-h-[100px]"
          disabled={isSaving}
        />
        <div className="flex gap-2 justify-end">
          <Button
            variant="outline"
            size="sm"
            onClick={() => {
              setEditValue(value);
              setIsEditing(false);
            }}
            disabled={isSaving}
          >
            Cancel
          </Button>
          <Button
            size="sm"
            onClick={async () => {
              if (editValue === value) {
                setIsEditing(false);
                return;
              }

              setIsSaving(true);
              try {
                await onSave(editValue);
                setIsEditing(false);
              } catch (error) {
                console.error("Failed to save");
                onApiError(error);
              } finally {
                setIsSaving(false);
              }
            }}
            disabled={isSaving}
          >
            {isSaving ? "Saving..." : "Save"}
          </Button>
        </div>
      </div>
    );

  return (
    <div
      className={cn(
        "group cursor-pointer hover:opacity-80 transition-opacity",
        className,
      )}
      onClick={() => setIsEditing(true)}
    >
      <p className={cn("text-muted-foreground", textClassName)}>{value}</p>
    </div>
  );
};
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2021",
    "useDefineForClassFields": true,
    "lib": ["ES2021", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noFallthroughCasesInSwitch": true,

    /* Import paths */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src", "convex", "shared"]
}
</file>

<file path="src/components/authenticated/agents/AgentDescription.tsx">
import * as React from "react";
import { useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import {
  EditableText,
  EditableTextHandle,
} from "@/components/ui/editable-text";
import { Pencil } from "lucide-react";

interface AgentDescriptionProps {
  agentId: Id<"agents">;
  name: string;
  description: string;
  personality: string;
  tools: string[];
}

export const AgentDescription: React.FC<AgentDescriptionProps> = ({
  agentId,
  name,
  description,
  personality,
  tools,
}) => {
  const updateAgent = useMutation(api.agents.mutations.updateMine);
  const descriptionEditRef = React.useRef<EditableTextHandle>(null);

  return (
    <Card className="p-6">
      <div className="flex justify-between items-center mb-2">
        <h2 className="text-lg font-semibold">About</h2>
        <Button
          variant="ghost"
          size="sm"
          className="h-8 w-8 p-0"
          onClick={() => descriptionEditRef.current?.startEditing()}
        >
          <Pencil className="h-4 w-4" />
        </Button>
      </div>
      <EditableText
        value={description}
        editRef={descriptionEditRef}
        onSave={async (newDescription) => {
          await updateAgent({
            agentId,
            name,
            description: newDescription,
            personality,
            tools,
          });
        }}
      />
    </Card>
  );
};
</file>

<file path="src/components/authenticated/agents/AgentPersonality.tsx">
import * as React from "react";
import { useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import {
  EditableText,
  EditableTextHandle,
} from "@/components/ui/editable-text";
import { Pencil } from "lucide-react";

interface AgentPersonalityProps {
  agentId: Id<"agents">;
  name: string;
  description: string;
  personality: string;
  tools: string[];
}

export const AgentPersonality: React.FC<AgentPersonalityProps> = ({
  agentId,
  name,
  description,
  personality,
  tools,
}) => {
  const updateAgent = useMutation(api.agents.mutations.updateMine);
  const personalityEditRef = React.useRef<EditableTextHandle>(null);

  return (
    <Card className="p-6">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-lg font-semibold">Personality</h2>
        <Button
          variant="ghost"
          size="sm"
          className="h-8 w-8 p-0"
          onClick={() => personalityEditRef.current?.startEditing()}
        >
          <Pencil className="h-4 w-4" />
        </Button>
      </div>
      <EditableText
        value={personality}
        editRef={personalityEditRef}
        onSave={async (newPersonality) => {
          await updateAgent({
            agentId,
            name,
            description,
            personality: newPersonality,
            tools,
          });
        }}
      />
    </Card>
  );
};
</file>

<file path="src/components/authenticated/chat/ConversationHeader.tsx">
import * as React from "react";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Doc, Id } from "../../../../convex/_generated/dataModel";
import { Skeleton } from "../../ui/skeleton";
import { Wrench, Trash2 } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogFooter,
} from "../../ui/dialog";
import { Button } from "../../ui/button";
import { Input } from "../../ui/input";
import { Confirm } from "../../ui/confirm";
import { routes } from "../../../routes";
import { ConversationParticipants } from "./ConversationParticipants";

interface ConversationHeaderProps {
  conversation: Doc<"conversations"> | undefined | null;
}

export const ConversationHeader: React.FC<ConversationHeaderProps> = ({
  conversation,
}) => {
  const updateConversation = useMutation(
    api.conversations.mutations.updateMine,
  );
  const deleteConversation = useMutation(
    api.conversations.mutations.removeMine,
  );
  const [isOpen, setIsOpen] = React.useState(false);
  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = React.useState(false);
  const [newTitle, setNewTitle] = React.useState(conversation?.title ?? "");

  React.useEffect(() => {
    if (conversation?.title) setNewTitle(conversation.title);
  }, [conversation?.title]);

  const handleSave = async () => {
    if (!conversation?._id || !newTitle.trim()) return;

    await updateConversation({
      conversationId: conversation?._id as Id<"conversations">,
      title: newTitle.trim(),
    });
    setIsOpen(false);
  };

  const handleDelete = async () => {
    if (!conversation?._id) return;

    await deleteConversation({
      conversationId: conversation?._id as Id<"conversations">,
    });
    setIsDeleteConfirmOpen(false);
    setIsOpen(false);
    routes.home().push();
  };

  return (
    <div className="h-14  flex items-center px-4 ">
      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogTrigger asChild>
          <Button
            variant="ghost"
            className="font-medium text-lg gap-2 bg-background"
          >
            {conversation?._id && !conversation ? (
              <Skeleton className="h-7 w-48" />
            ) : (
              <>
                {conversation?.title}
                <Wrench className="h-4 w-4 opacity-20" />
              </>
            )}
          </Button>
        </DialogTrigger>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Conversation Settings</DialogTitle>
          </DialogHeader>
          <div className="py-4">
            <label className="text-sm font-medium mb-2 block">
              Conversation Name
            </label>
            <Input
              value={newTitle}
              onChange={(e) => setNewTitle(e.target.value)}
              placeholder="Enter conversation name"
            />
          </div>
          <DialogFooter className="flex justify-between items-center">
            <Button
              variant="ghost"
              size="sm"
              className="text-destructive hover:text-destructive hover:bg-destructive/10"
              onClick={() => setIsDeleteConfirmOpen(true)}
            >
              <Trash2 className="h-4 w-4" />
              Delete Conversation
            </Button>
            <Button onClick={handleSave}>Save Changes</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Confirm
        open={isDeleteConfirmOpen}
        onOpenChange={setIsDeleteConfirmOpen}
        title="Delete Conversation"
        description={`Are you sure you want to delete "${conversation?.title}"? This action cannot be undone.`}
        confirmText="Delete Conversation"
        variant="destructive"
        onConfirm={handleDelete}
      />

      <ConversationParticipants conversation={conversation} />
    </div>
  );
};
</file>

<file path="src/components/authenticated/chat/ConversationParticipants.tsx">
import * as React from "react";
import { useQuery } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Doc } from "../../../../convex/_generated/dataModel";
import { ParticipantsDialog } from "./ParticipantsDialog";
import { Avatar, AvatarImage, AvatarFallback } from "../../ui/avatar";

interface ConversationParticipantsProps {
  conversation: Doc<"conversations"> | undefined | null;
}

export const ConversationParticipants: React.FC<
  ConversationParticipantsProps
> = ({ conversation }) => {
  const avatars = useQuery(
    api.conversationParticipants.queries.listAvatars,
    conversation
      ? {
          conversationId: conversation._id,
        }
      : "skip",
  );

  if (!conversation) return null;

  return (
    <ParticipantsDialog
      conversation={conversation}
      trigger={
        <div className="flex -space-x-2 ml-auto cursor-pointer hover:opacity-80 transition-opacity">
          {avatars?.slice(0, 3).map((url, i) => (
            <Avatar key={i} className="ring-2 ring-background w-8 h-8">
              <AvatarImage src={url} />
              <AvatarFallback>?</AvatarFallback>
            </Avatar>
          ))}
          {(avatars?.length ?? 0) > 3 && (
            <div className="w-8 h-8 rounded-full bg-muted ring-2 ring-background flex items-center justify-center text-xs font-medium">
              +{avatars!.length - 3}
            </div>
          )}
        </div>
      }
    />
  );
};
</file>

<file path="src/components/authenticated/chat/SystemMessage.tsx">
import * as React from "react";
import { Doc } from "convex/_generated/dataModel";
import { useTimeAgo } from "@/components/misc/hooks";
import { InfoIcon, MoreHorizontalIcon } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";

interface Props {
  message: Doc<"conversationMessages">;
}

export const SystemMessage: React.FC<Props> = ({ message }) => {
  if (message.kind != "system")
    throw new Error("Message is not a system message");

  const timeAgo = useTimeAgo(message._creationTime);
  const hasMeta = message.meta !== undefined;

  return (
    <div className="flex items-center justify-center my-4">
      {hasMeta ? (
        <Dialog>
          <DialogTrigger asChild>
            <div className="flex items-center gap-2 max-w-[80%] rounded-lg bg-secondary/50 px-4 py-2 text-sm text-secondary-foreground cursor-pointer group relative">
              <InfoIcon className="h-4 w-4" />
              <div className="flex-1">{message.content}</div>
              <div className="text-xs text-secondary-foreground/70">
                {timeAgo}
              </div>
              <div className="opacity-0 group-hover:opacity-100 transition-opacity ml-1">
                <MoreHorizontalIcon className="h-4 w-4" />
              </div>
            </div>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Message Details</DialogTitle>
            </DialogHeader>
            <div className="mt-4 space-y-4">
              <div className="text-sm">{message.content}</div>
              <div className="border-t pt-4">
                <h3 className="font-medium mb-2">Additional Information</h3>
                <pre className="bg-secondary/30 p-4 rounded-md whitespace-pre-wrap text-xs overflow-auto max-h-[400px]">
                  {JSON.stringify(message.meta, null, 2)}
                </pre>
              </div>
            </div>
          </DialogContent>
        </Dialog>
      ) : (
        <div className="flex items-center gap-2 max-w-[80%] rounded-lg bg-secondary/50 px-4 py-2 text-sm text-secondary-foreground">
          <InfoIcon className="h-4 w-4" />
          <div className="flex-1">{message.content}</div>
          <div className="text-xs text-secondary-foreground/70">{timeAgo}</div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/authenticated/conversations/ConversationList.tsx">
import * as React from "react";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Plus } from "lucide-react";
import { useApiErrorHandler } from "../../misc/errors";
import { ConversationItem } from "./ConversationItem";
import { useCurrentConversationId, routes } from "../../../routes";

const DEFAULT_THREAD_TITLE = "New Conversation";

interface ConversationListProps {}

export const ConversationList: React.FC<ConversationListProps> = ({}) => {
  const conversations = useQuery(api.conversations.queries.listMine);
  const createConversation = useMutation(api.conversations.mutations.create);
  const onApiError = useApiErrorHandler();
  const currentConversationId = useCurrentConversationId();

  const handleCreateConversation = async () => {
    try {
      const conversationId = await createConversation({
        title: DEFAULT_THREAD_TITLE,
      });
      routes.conversation({ conversationId }).push();
    } catch (error) {
      onApiError(error);
    }
  };

  return (
    <>
      <div className="h-24 border-b border-border relative overflow-hidden">
        <img
          src="/logo-white.png"
          alt="Agent Inbox"
          className="absolute -right-0 -top-2 h-32 object-cover"
        />
        <div className="absolute inset-x-0 bottom-0 h-12 bg-gradient-to-t from-card to-transparent" />
      </div>
      <div className="p-4">
        <button
          onClick={handleCreateConversation}
          className="w-full bg-primary text-primary-foreground px-4 py-2 rounded-md flex items-center justify-center gap-2 hover:bg-primary/90"
        >
          <Plus className="h-5 w-5" />
          New Conversation
        </button>
      </div>
      <div className="flex-1 overflow-y-auto">
        {conversations?.map((conversation) => (
          <ConversationItem
            key={conversation._id}
            id={conversation._id}
            title={conversation.title}
            lastMessageTime={conversation._creationTime}
            isSelected={conversation._id === currentConversationId}
            onSelect={(id) =>
              routes.conversation({ conversationId: id }).push()
            }
          />
        ))}
      </div>
    </>
  );
};
</file>

<file path="src/components/authenticated/conversations/UserProfile.tsx">
import * as React from "react";
import { Card } from "../../ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "../../ui/avatar";
import { SignOutButton } from "../SignOutButton";
import { api } from "../../../../convex/_generated/api";
import { useQuery } from "convex/react";

interface UserProfileProps {}

export const UserProfile: React.FC<UserProfileProps> = ({}) => {
  const me = useQuery(api.users.queries.getMe);
  return (
    <Card className="m-2 p-2 bg-accent/50 border-accent/50">
      <div className="flex items-center gap-3">
        <Avatar>
          <AvatarImage src={me?.image} />
          <AvatarFallback>{me?.name?.[0] ?? "U"}</AvatarFallback>
        </Avatar>
        <div className="flex-1 min-w-0">
          <div className="font-medium text-primary-foreground truncate">
            {me?.name}
          </div>
          <div className="text-xs text-muted-foreground/80 truncate">
            {me?.email}
          </div>
        </div>
        <SignOutButton />
      </div>
    </Card>
  );
};
</file>

<file path="src/components/ui/agent-avatar.tsx">
import * as React from "react";
import { cn } from "@/lib/utils";

interface AgentAvatarProps extends React.HTMLAttributes<HTMLDivElement> {
  avatarUrl: string;
  name: string;
  size?: "xs" | "sm" | "md" | "lg";
}

export const AgentAvatar = React.forwardRef<HTMLDivElement, AgentAvatarProps>(
  ({ avatarUrl, name, size = "md", className, ...props }, ref) => {
    const sizeClasses = {
      xs: "h-4 w-4",
      sm: "h-8 w-8",
      md: "h-12 w-12",
      lg: "h-48 w-48",
    };

    const borderClasses = {
      xs: "border",
      sm: "border-2",
      md: "border-2",
      lg: "border-4",
    };

    return (
      <div
        ref={ref}
        className={cn("relative inline-block", className)}
        {...props}
      >
        <div
          className={cn(
            "absolute inset-0 rounded-full bg-primary/10 -z-10 scale-125",
            sizeClasses[size],
          )}
        />

        <div
          className={cn(
            "relative rounded-full overflow-visible border-primary bg-gradient-to-b from-primary/40  to-primary/5",
            sizeClasses[size],
            borderClasses[size],
          )}
        >
          <img
            src={avatarUrl}
            alt={name}
            className="w-full h-full object-cover scale-110"
          />
        </div>
      </div>
    );
  },
);
</file>

<file path="src/routes.ts">
import { createRouter, defineRoute, param } from "type-route";

export const { RouteProvider, useRoute, routes } = createRouter({
  home: defineRoute("/"),
  conversation: defineRoute(
    {
      conversationId: param.path.string,
    },
    (p) => `/conversation/${p.conversationId}`,
  ),
  agent: defineRoute(
    {
      agentId: param.path.string,
    },
    (p) => `/agent/${p.agentId}`,
  ),
});

export type ConversationParams = {
  conversationId: string;
  taskId?: string;
};

// Helper to get current conversation ID if we're on a conversation route
export function useCurrentConversationId(): string | undefined {
  const route = useRoute();
  if (route.name === "conversation") return route.params.conversationId;
  return undefined;
}

export function useCurrentAgentId() {
  const route = useRoute();
  if (route.name === "agent") return route.params.agentId;
  return undefined;
}
</file>

<file path="src/components/authenticated/sidebar/ConversationList.tsx">
import * as React from "react";
import { useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Plus } from "lucide-react";
import { useApiErrorHandler } from "../../misc/errors";
import { routes, useCurrentConversationId } from "../../../routes";
import { Button } from "@/components/ui/button";
import { useQuery } from "convex-helpers/react/cache";

const DEFAULT_THREAD_TITLE = "New Conversation";

export const ConversationList = () => {
  const conversations = useQuery(api.conversations.queries.listMine);
  const createConversation = useMutation(api.conversations.mutations.create);
  const onApiError = useApiErrorHandler();
  const currentConversationId = useCurrentConversationId();

  return (
    <>
      <div className="p-4">
        <Button
          className="w-full"
          variant="default"
          onClick={() =>
            createConversation({ title: DEFAULT_THREAD_TITLE })
              .then((conversationId) =>
                routes.conversation({ conversationId }).push(),
              )
              .catch(onApiError)
          }
        >
          <Plus className="h-5 w-5" />
          New Conversation
        </Button>
      </div>
      <div className="flex-1 overflow-y-auto">
        {conversations?.map((conversation) => (
          <div
            key={conversation._id}
            onClick={() =>
              routes.conversation({ conversationId: conversation._id }).push()
            }
            className={`p-4 cursor-pointer hover:bg-accent ${
              conversation._id === currentConversationId ? "bg-accent" : ""
            }`}
          >
            <div className="font-medium text-primary-foreground truncate">
              {conversation.title}
            </div>
            <div className="text-sm text-muted-foreground/80 truncate">
              {new Date(conversation._creationTime).toLocaleTimeString()}
            </div>
          </div>
        ))}
      </div>
    </>
  );
};
</file>

<file path="convex/ai/history.ts">
import { internal } from "../_generated/api";
import { isNotNullOrUndefined } from "../../shared/filter";
import { Id } from "../_generated/dataModel";
import { ActionCtx, QueryCtx } from "../_generated/server";

export const getMessageHistory = async (
  ctx: ActionCtx,
  args: {
    conversationId: Id<"conversations">;
    messageId: Id<"conversationMessages">;
    count: number;
  },
) => {
  return await ctx
    .runQuery(
      internal.conversationMessages.internalQueries
        .listMessagesHistoryForAgentGeneration,
      { conversationId: args.conversationId, count: args.count },
    )
    .then((messages) =>
      messages
        .filter((m) => (m.message._id == args.messageId ? null : m)) // exclude the message we are looking at
        .filter(isNotNullOrUndefined),
    );
};
</file>

<file path="convex/ai/messages.ts">
import { CoreMessage } from "ai";
import { ActionCtx } from "../_generated/server";
import { getMessageHistory } from "./history";
import { Doc } from "../_generated/dataModel";
import { ParticipantUserOrAgent } from "../conversationParticipants/model";
import { createMentionString } from "../../shared/mentions";

export const gatherMessages = async (
  ctx: ActionCtx,
  {
    systemMessage,
    conversation,
    message,
    messageAuthor,
  }: {
    systemMessage: string;
    conversation: Doc<"conversations">;
    message: Doc<"conversationMessages">;
    messageAuthor: ParticipantUserOrAgent;
  },
): Promise<CoreMessage[]> => {
  const messageHistory = await getMessageHistory(ctx, {
    conversationId: conversation._id,
    messageId: message._id,
    count: 30,
  });

  const messages: CoreMessage[] = [
    {
      role: "system",
      content: systemMessage,
    },
    ...messageHistory.map((m) => ({
      role: "user" as const,
      content: `${createMentionString(
        m.author.kind === "user"
          ? {
              kind: "user" as const,
              userId: m.author._id,
              name: m.author.name ?? "Unknown User",
            }
          : {
              kind: "agent" as const,
              agentId: m.author._id,
              name: m.author.name,
            },
      )} said: ${m.message.content}`,
    })),
    {
      role: "user" as const,
      content: `${createMentionString(
        messageAuthor.kind === "user"
          ? {
              kind: "user" as const,
              userId: messageAuthor.user._id,
              name: messageAuthor.user.name ?? "Unknown User",
            }
          : {
              kind: "agent" as const,
              agentId: messageAuthor.agent._id,
              name: messageAuthor.agent.name,
            },
      )} said: ${message.content}`,
    },
  ];

  console.log(`agent messages:`, messages);

  return messages;
};
</file>

<file path="src/components/authenticated/agents/AgentTools.tsx">
import * as React from "react";
import { useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Pencil, X, Plus } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  UserChoosableToolName,
  userChoosableToolDefinitions,
  toolDefinitions,
  AgentToolName,
} from "../../../../shared/tools";

interface AgentToolsProps {
  agentId: Id<"agents">;
  name: string;
  description: string;
  personality: string;
  tools: AgentToolName[];
}

export const AgentTools: React.FC<AgentToolsProps> = ({
  agentId,
  name,
  description,
  personality,
  tools,
}) => {
  const updateAgent = useMutation(api.agents.mutations.updateMine);
  const [isEditing, setIsEditing] = React.useState(false);

  const handleRemoveTool = async (toolToRemove: AgentToolName) => {
    await updateAgent({
      agentId,
      name,
      description,
      personality,
      tools: tools.filter((tool) => tool !== toolToRemove),
    });
  };

  const handleAddTool = async (toolToAdd: UserChoosableToolName) => {
    if (tools.includes(toolToAdd)) return;
    await updateAgent({
      agentId,
      name,
      description,
      personality,
      tools: [...tools, toolToAdd],
    });
  };

  // Get available tools that aren't already added
  const availableTools: Array<
    [UserChoosableToolName, (typeof toolDefinitions)[UserChoosableToolName]]
  > = [];

  // Only include tools from userChoosableToolDefinitions
  Object.keys(userChoosableToolDefinitions).forEach((key) => {
    const toolKey = key as UserChoosableToolName;
    if (!tools.includes(toolKey)) {
      availableTools.push([toolKey, toolDefinitions[toolKey]]);
    }
  });

  return (
    <Card className="p-6">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-lg font-semibold">Tools</h2>
        <Button
          variant="ghost"
          size="sm"
          className="h-8 w-8 p-0"
          onClick={() => setIsEditing(!isEditing)}
        >
          <Pencil className="h-4 w-4" />
        </Button>
      </div>
      <div className="flex flex-wrap gap-2">
        {tools.map((tool) => (
          <Badge
            key={tool}
            variant="secondary"
            className="flex items-center gap-1"
          >
            {tool}
            {isEditing && (
              <button
                onClick={() => handleRemoveTool(tool)}
                className="ml-1 hover:text-destructive"
              >
                <X className="h-3 w-3" />
              </button>
            )}
          </Badge>
        ))}
        {isEditing && availableTools.length > 0 && (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm" className="h-6">
                <Plus className="h-3 w-3 mr-1" />
                Add Tool
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent>
              {availableTools.map(([key, tool]) => (
                <DropdownMenuItem key={key} onClick={() => handleAddTool(key)}>
                  <div>
                    <div className="font-medium">{tool.name}</div>
                    <div className="text-xs text-muted-foreground">
                      {tool.description}
                    </div>
                  </div>
                </DropdownMenuItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
        )}
      </div>
    </Card>
  );
};
</file>

<file path="src/components/authenticated/chat/AgentMention.tsx">
import * as React from "react";
import { AgentAvatar } from "@/components/ui/agent-avatar";
import { useQuery } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";
import { routes } from "@/routes";
import { BaseMention } from "./BaseMention";
import { Bot } from "lucide-react";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";

interface AgentMentionProps {
  display: string;
  agentId: Id<"agents">;
  isInUserMessage?: boolean;
}

export const AgentMention: React.FC<AgentMentionProps> = ({
  display,
  agentId,
  isInUserMessage,
}) => {
  const agent = useQuery(api.agents.queries.findMention, { agentId });
  if (!agent) return null;

  const handleClick = () => {
    routes.agent({ agentId }).push();
  };

  return (
    <BaseMention
      display={agent?.name ?? display}
      isInUserMessage={isInUserMessage}
      onClick={agent?._id ? handleClick : undefined}
      avatar={
        agent ? (
          <AgentAvatar
            size="xs"
            avatarUrl={agent.avatarUrl}
            name={agent.name ?? display}
            className="translate-y-[1px]"
          />
        ) : (
          <Avatar className="h-4 w-4 translate-y-[1px]">
            <AvatarFallback className="bg-muted">
              <Bot className="h-3 w-3" />
            </AvatarFallback>
          </Avatar>
        )
      }
    />
  );
};
</file>

<file path="src/components/authenticated/chat/AgentSelector.tsx">
import * as React from "react";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Doc, Id } from "../../../../convex/_generated/dataModel";
import { Avatar, AvatarImage, AvatarFallback } from "../../ui/avatar";
import { Button } from "../../ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { UserPlus } from "lucide-react";

interface AgentSelectorProps {
  conversation: Doc<"conversations">;
  trigger?: React.ReactNode;
}

export const AgentSelector: React.FC<AgentSelectorProps> = ({
  conversation,
  trigger,
}) => {
  const agents = useQuery(api.agents.queries.listMine);
  const addAgent = useMutation(api.conversationParticipants.mutations.addAgent);
  const participants = useQuery(
    api.conversationParticipants.queries.listDetailsForMe,
    {
      conversationId: conversation._id,
    },
  );

  // Filter out agents that are already in the conversation
  const availableAgents = agents?.filter(
    (agent) =>
      !participants?.some((p) => p.kind === "agent" && p.name === agent.name),
  );

  const handleAddAgent = async (agentId: Id<"agents">) => {
    await addAgent({
      conversationId: conversation._id,
      agentId,
    });
  };

  if (!availableAgents?.length) return null;

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        {trigger || (
          <Button className="w-full" variant="outline">
            <UserPlus className="mr-2 h-4 w-4" />
            Add Agent
          </Button>
        )}
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[240px]">
        {availableAgents.map((agent) => (
          <DropdownMenuItem
            key={agent._id}
            onClick={() => handleAddAgent(agent._id)}
            className="flex items-center gap-2 p-2"
          >
            <Avatar className="h-6 w-6">
              <AvatarImage src={agent.avatarUrl} />
              <AvatarFallback>{agent.name[0]}</AvatarFallback>
            </Avatar>
            <div className="flex flex-col">
              <div className="text-sm font-medium">{agent.name}</div>
              <div className="text-xs text-muted-foreground line-clamp-1">
                {agent.description}
              </div>
            </div>
          </DropdownMenuItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
};
</file>

<file path="src/components/authenticated/chat/ChatMessage.tsx">
import * as React from "react";
import { Doc } from "convex/_generated/dataModel";
import { SystemMessage } from "./SystemMessage";
import { ParticipantMessage } from "./ParticipantMessage";
import { exhaustiveCheck } from "../../../../shared/misc";

interface ChatMessageProps {
  message: Doc<"conversationMessages">;
}

export const ChatMessage: React.FC<ChatMessageProps> = ({ message }) => {
  if (message.kind == "system") return <SystemMessage message={message} />;

  if (message.kind == "participant")
    return <ParticipantMessage message={message} />;

  exhaustiveCheck(message);
};
</file>

<file path="src/components/authenticated/chat/UserMention.tsx">
import * as React from "react";
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";
import { useQuery } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";
import { BaseMention } from "./BaseMention";
import { Ghost } from "lucide-react";

interface UserMentionProps {
  display: string;
  userId: Id<"users">;
  isInUserMessage?: boolean;
}

export const UserMention: React.FC<UserMentionProps> = ({
  display,
  userId,
  isInUserMessage,
}) => {
  const user = useQuery(api.users.queries.findMention, { userId });



  return (
    <BaseMention
      display={user?.name ?? display}
      isInUserMessage={isInUserMessage}
      avatar={
        <Avatar className="h-4 w-4 translate-y-[1px]">
          {user?.image ? (
            <AvatarImage src={user.image} />
          ) : (
            <AvatarFallback className="bg-muted">
              <Ghost className="h-3 w-3" />
            </AvatarFallback>
          )}
        </Avatar>
      }
    />
  );
};
</file>

<file path="convex/ai/utils.ts">
import { internal } from "../_generated/api";
import { Doc, Id } from "../_generated/dataModel";
import { ActionCtx } from "../_generated/server";
import * as Agents from "../agents/model";

export const sendSystemMessageToConversation = async (
  ctx: ActionCtx,
  args: {
    conversationId: Id<"conversations">;
    content: string;
    meta?: any;
  },
) =>
  ctx.runMutation(
    internal.conversationMessages.internalMutations.sendSystemMessage,
    {
      conversationId: args.conversationId as Id<"conversations">,
      content: args.content,
      meta: args.meta,
    },
  );

export const getAgentAndEnsureItIsJoinedToConversation = async (
  ctx: ActionCtx,
  args: {
    agentId: Id<"agents">;
    conversationId: Id<"conversations">;
  },
) => {
  // Get the referenced agent
  const agent = await ctx.runQuery(internal.agents.internalQueries.find, {
    agentId: args.agentId,
  });

  if (!agent)
    throw new Error(`Agent of id '${args.agentId}' could not be found`);

  // Get or create the participant for this agent in the conversation
  const participant = await ctx.runMutation(
    internal.conversationParticipants.internalMutations
      .addAgentIfNotAlreadyJoined,
    {
      conversationId: args.conversationId,
      agentId: agent._id,
    },
  );

  return { agent, participant };
};

export const getTriageAgent = async (ctx: ActionCtx) => {
  const agent = await ctx.runQuery(
    internal.agents.internalQueries.findSystemAgentByKind,
    { systemAgentKind: "triage" },
  );
  if (agent) return agent;
  return await ctx.runMutation(
    internal.agents.internalMutations.createSystemAgent,
    {
      systemAgentKind: "triage",
      name: "System Triage Agent",
      description: `Triage messages to the correct agent`,
      personality: `Helpful, concise`,
      avatarUrl: Agents.createAgentAvatarUrl(`system-triage`),
      tools: [],
      lastActiveTime: Date.now(),
      kind: "system_agent",
    },
  );
};

export const getTriageAgentAndEnsureItIsJoinedToConversation = async (
  ctx: ActionCtx,
  conversationId: Id<"conversations">,
) => {
  const agent = await getTriageAgent(ctx);

  const participant = await ctx.runMutation(
    internal.conversations.internalMutations
      .joinTriageAgentToConversationIfNotAlreadyJoined,
    {
      conversationId,
    },
  );

  if (participant.kind != "agent")
    throw new Error(
      `Participant is not an agent, it should be as it is the triage agent`,
    );

  return { agent, participant };
};

/**
 * Generic function to handle AI generation with consistent status management
 */
export const runAgentAIGeneration = async <T>(
  ctx: ActionCtx,
  args: {
    agent: Doc<"agents">;
    participant: Doc<"conversationParticipants"> & { kind: "agent" };
    conversation: Doc<"conversations">;
    generateAIResponse: () => Promise<T>;
  },
) => {
  // Set the agent's status to thinking
  await ctx.runMutation(
    internal.conversationParticipants.internalMutations.updateParticipantStatus,
    {
      participantId: args.participant._id,
      status: "thinking",
    },
  );

  try {
    return await args.generateAIResponse();
  } catch (error: unknown) {
    await handleAgentError(ctx, {
      error,
      conversationId: args.conversation._id,
      errorContext: "responding to message",
    });
    return null;
  } finally {
    // No longer thinking
    await ctx.runMutation(
      internal.conversationParticipants.internalMutations
        .updateParticipantStatus,
      {
        participantId: args.participant._id,
        status: "inactive",
      },
    );
  }
};

/**
 * Handles agent errors with a consistent approach
 */
export const handleAgentError = async (
  ctx: ActionCtx,
  args: {
    error: unknown;
    conversationId: Id<"conversations">;
    errorContext: string;
  },
) => {
  console.error(`Error while ${args.errorContext}:`, args.error);

  const errorMessage =
    args.error instanceof Error ? args.error.message : "Unknown error";

  // Send error message to conversation
  await sendSystemMessageToConversation(ctx, {
    conversationId: args.conversationId,
    content: `Error while ${args.errorContext}: ${errorMessage}`,
    meta: {
      error: errorMessage,
      errorContext: args.errorContext,
      fullError:
        args.error instanceof Error
          ? {
              message: args.error.message,
              stack: args.error.stack,
              name: args.error.name,
            }
          : String(args.error),
    },
  });
};

/**
 * Process AI result and handle noOp cases
 */
export const processAgentAIResult = async (
  ctx: ActionCtx,
  args: {
    result: { text: string; toolCalls: Array<{ toolName: string; args: any }> };
    agent: Doc<"agents">;
    conversation: Doc<"conversations">;
    participant: Doc<"conversationParticipants"> & { kind: "agent" };
    sendMessage: (text: string) => Promise<void>;
  },
) => {
  console.log(`Agent result:`, args.result);
  console.log(`Tool Calls:`, args.result.toolCalls);

  if (args.result.text !== "") {
    await args.sendMessage(args.result.text);
  } else {
    const noOp = args.result.toolCalls.find((t) => t.toolName === "noOutput");
    if (noOp) {
      await sendSystemMessageToConversation(ctx, {
        conversationId: args.conversation._id,
        content: `Agent ${args.agent.name} decided not to respond to the message because: "${noOp.args.reasoning}"`,
        meta: {
          toolName: "noOutput",
          reasoning: noOp.args.reasoning,
          agentName: args.agent.name,
          agentId: args.agent._id,
        },
      });
    }
  }
};
</file>

<file path="convex/conversationMessages/schema.ts">
import { defineTable } from "convex/server";
import { v } from "convex/values";

export const conversationMessageReferenceSchemaValidator = v.union(
  v.object({
    kind: v.literal("agent"),
    agentId: v.id("agents"),
  }),
  v.object({
    kind: v.literal("user"),
    userId: v.id("users"),
  }),
);

export const conversationMessageReferencesSchemaValidator = v.array(
  conversationMessageReferenceSchemaValidator,
);

const common = {
  conversationId: v.id("conversations"),
  content: v.string(),
};

export const conversationParticipantMessageSchemaValidator = v.object({
  ...common,
  kind: v.literal("participant"),
  authorParticipantId: v.id("conversationParticipants"),
});

export const conversationAgentMessageSchemaValidator = v.union(
  conversationParticipantMessageSchemaValidator,
  v.object({
    ...common,
    kind: v.literal("system"),
    meta: v.optional(v.any()),
  }),
);

export const conversationMessagesTable = defineTable(
  conversationAgentMessageSchemaValidator,
)
  .index("by_conversationId", ["conversationId"])
  .index("by_conversationId_kind", ["conversationId", "kind"]);
</file>

<file path="convex/conversationParticipants/schema.ts">
import { v } from "convex/values";
import { defineTable } from "convex/server";

export const conversationParticipantStatusSchemaValidator = v.union(
  v.literal("inactive"),
  v.literal("thinking"),
);

const common = {
  conversationId: v.id("conversations"),
  addedAt: v.number(),
  status: conversationParticipantStatusSchemaValidator,
  isRemoved: v.boolean(),
};

export const conversationParticipantIdentifierSchemaValidator = v.union(
  v.object({
    kind: v.literal("agent"),
    agentId: v.id("agents"),
  }),
  v.object({
    kind: v.literal("user"),
    userId: v.id("users"),
  }),
);

export const conversationParticipantsSchemaValidator = v.union(
  v.object({
    kind: v.literal("agent"),
    agentId: v.id("agents"),
    ...common,
  }),
  v.object({
    kind: v.literal("user"),
    userId: v.id("users"),
    ...common,
  }),
);

export const conversationParticipantsTable = defineTable(
  conversationParticipantsSchemaValidator,
)
  .index("by_conversationId", ["conversationId"])
  .index("by_conversationId_isRemoved", ["conversationId", "isRemoved"])
  .index("by_userId", ["userId"])
  .index("by_conversationId_kind_agentId", [
    "conversationId",
    "kind",
    "agentId",
  ])
  .index("by_conversationId_kind_userId", ["conversationId", "kind", "userId"])
  .index("by_conversationId_status", ["conversationId", "status"]);
</file>

<file path="shared/misc.ts">
import { Id } from "../convex/_generated/dataModel";

export function pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K> {
  const ret: any = {};
  keys.forEach((key) => {
    ret[key] = obj[key];
  });
  return ret;
}

export function exhaustiveCheck(param: never): never {
  throw new Error(`Exhaustive check failed: ${param}`);
}

export function wait(ms: number) {
  return new Promise((resolve, reject) => setTimeout(resolve, ms));
}

export const iife = <T>(fn: () => T): T => fn();

export type MessageReference =
  | { kind: "agent"; agentId: Id<"agents">; display: string }
  | { kind: "user"; userId: Id<"users">; display: string };

export type AgentTool = {
  name: string;
  description: string;
  parameters: Record<
    string,
    {
      type: string;
      description: string;
      required?: boolean;
    }
  >;
};
</file>

<file path="README.md">
![agent inbox screenshot](./media/screenshot.png)

# Agent Inbox

A multi-agent AI chat running on Convex

## Setup

1. Install dependencies: `bun install`

2. Start the dev server: `bun dev` this will step you though getting up a new convex project

3. Provide the API tokens needed: 
+ OPENAI_API_KEY - for AI models - `bun convex env set OPENAI_API_KEY {YOUR_KEY}`
+ EXA_API_KEY - for web search tooling - `bun convex env set EXA_API_KEY {YOUR_KEY}`
+ RESEND_API_KEY - for emailing tooling - `bun convex env set RESEND_API_KEY {YOUR_KEY}`

4. Setup convex auth tokens: `bunx @convex-dev/auth`

5. Setup Github OAuth: https://labs.convex.dev/auth/config/oauth/github

## Initial Idea

The idea is that we are building an agentic inbox application that uses Convex and Mastra.AI

The main idea is that you have a chat experience simmilar to slack except you are chatting with a number of AI agents. 

On the left is a sidebar with conversation history and a button to let you make a new conversation, then on the right is the main chat window for the current conversation.

In a new conversation you can "at" agents to directly address them when you are chatting. 

The key here is that an agent can go off and do something on behalf of a user and then come back and add a message into the chat and then one agent can "at" another agent to reference it if it thinks that another agent should participate in a discussion.

When an agent is "atted" (@) it can go off on a "Task" this "Task" might involve a number of steps like searching the web, searching for documents etc before it comes back. This Task history isnt shown in the main chat but can be drilled down into if the user wishs. This should open up as a sidebar on the right hand side like a slack conversation.

The user can create new agents at any time. Each agent can be given different personality prompts and tools they have access to so that they behave differntly. 

All agents can be viewed from an agent gallery modal.
</file>

<file path="convex/agents/model.ts">
import { DatabaseReader, MutationCtx, QueryCtx } from "../_generated/server";
import { Doc, Id } from "../_generated/dataModel";
import * as Users from "../users/model";
import { predefinedAgents } from "../../shared/predefinedAgents";
import { systemAgentKindValidator, systemAgentValidator } from "./schema";

export const find = async (
  db: DatabaseReader,
  { agentId }: { agentId: Id<"agents"> },
) => {
  return await db.get(agentId);
};

export const get = async (
  db: DatabaseReader,
  { agentId }: { agentId: Id<"agents"> },
) => {
  const agent = await find(db, { agentId });
  if (!agent) throw new Error(`Agent not found ${agentId}`);
  return agent;
};

export const createAgentAvatarUrl = (seed: string) => {
  return `https://api.dicebear.com/7.x/bottts/svg?seed=${seed}`;
};

export const createAgent = async (ctx: MutationCtx) => {
  const userId = await Users.getMyId(ctx);
  const randomIndex = Math.floor(Math.random() * predefinedAgents.length);
  const selectedAgent = predefinedAgents[randomIndex];

  return await ctx.db.insert("agents", {
    name: selectedAgent.name,
    description: selectedAgent.description,
    personality: selectedAgent.personality,
    tools: selectedAgent.tools,
    createdBy: userId,
    lastActiveTime: Date.now(),
    avatarUrl: createAgentAvatarUrl(selectedAgent.name),
    kind: "user_agent",
  });
};

export const createSystemAgent = async (
  ctx: MutationCtx,
  args: typeof systemAgentValidator.type,
) => {
  return await ctx.db.insert("agents", {
    ...args,
    kind: "system_agent",
  });
};

export const listForUser = async (
  db: DatabaseReader,
  { userId }: { userId: Id<"users"> },
) => {
  return await db
    .query("agents")
    .withIndex("by_creator", (q) => q.eq("createdBy", userId))
    .collect();
};

export const listMine = async (ctx: QueryCtx) => {
  const userId = await Users.getMyId(ctx);
  return listForUser(ctx.db, { userId });
};

export const findMine = async (
  ctx: QueryCtx,
  { agentId }: { agentId: Id<"agents"> },
) => {
  const userId = await Users.getMyId(ctx);
  const agent = await ctx.db.get(agentId);
  if (!agent) throw new Error("Access denied");
  if (agent.kind != "user_agent") throw new Error("Access denied");
  if (agent.createdBy != userId) throw new Error("Access denied");
  return agent;
};

export const getMine = async (
  ctx: QueryCtx,
  { agentId }: { agentId: Id<"agents"> },
) => {
  const agent = await findMine(ctx, { agentId });
  if (!agent) throw new Error("Agent not found");
  return agent;
};

export const ensureICanAccessAgent = async (
  ctx: QueryCtx,
  { agentId }: { agentId: Id<"agents"> },
) => {
  const agent = await getMine(ctx, { agentId });
  if (!agent) throw new Error("Access denied");
};

export const updateMine = async (
  ctx: MutationCtx,
  {
    agentId,
    name,
    description,
    personality,
    tools,
  }: {
    agentId: Id<"agents">;
    name: string;
    description: string;
    personality: string;
    tools: string[];
  },
) => {
  return await ctx.db.patch(agentId, {
    name,
    description,
    personality,
    tools,
  });
};

export const remove = async (
  ctx: MutationCtx,
  { agentId }: { agentId: Id<"agents"> },
) => {
  await ctx.db.delete(agentId);
};

export const findSystemAgentByKind = async (
  db: DatabaseReader,
  {
    systemAgentKind,
  }: { systemAgentKind: typeof systemAgentKindValidator.type },
) => {
  const agent = await db
    .query("agents")
    .withIndex("by_system_agent_kind", (q) =>
      q.eq("systemAgentKind", systemAgentKind),
    )
    .first();
  return agent;
};

export const getSystemAgentByKind = async (
  db: DatabaseReader,
  {
    systemAgentKind,
  }: { systemAgentKind: typeof systemAgentKindValidator.type },
) => {
  const agent = await findSystemAgentByKind(db, { systemAgentKind });
  if (!agent) throw new Error(`System agent '${systemAgentKind}' not found`);
  return agent;
};

export const getTriageAgent = async (db: DatabaseReader) => {
  return await getSystemAgentByKind(db, { systemAgentKind: "triage" });
};
</file>

<file path="convex/agents/schema.ts">
import { v } from "convex/values";
import { toolDefinitions } from "../../shared/tools";

const common = {
  name: v.string(),
  description: v.string(),
  personality: v.string(),
  avatarUrl: v.string(),
  tools: v.array(v.string()),
  lastActiveTime: v.number(),
};

export const systemAgentKindValidator = v.union(v.literal("triage"));

export const systemAgentValidator = v.object({
  ...common,
  kind: v.literal("system_agent"),
  systemAgentKind: systemAgentKindValidator,
});

export const agentsSchemaValidator = v.union(
  v.object({
    ...common,
    kind: v.literal("user_agent"),
    createdBy: v.id("users"),
  }),
  systemAgentValidator,
);
</file>

<file path="shared/tools.ts">
import { z } from "zod";
import { Id } from "../convex/_generated/dataModel";
import { pick } from "convex-helpers";

export const toolDefinitions = {
  listConversationParticipants: {
    name: "listConversationParticipants",
    description: "A tool for listing the participants in a conversation.",
    parameters: z.object({
      conversationId: z
        .string()
        .describe("The ID of the conversation to list participants for"),
    }),
  },
  listAgents: {
    name: "listAgents",
    description: "Allows listing of all of a user's agents",
    parameters: z.object({
      userId: z.string().describe("The ID of the user whose agents to list"),
    }),
  },
  messageAnotherAgent: {
    name: "messageAnotherAgent",
    description: "Allows sending of a message to another agent",
    parameters: z.object({
      target: z
        .object({
          agentId: z.string(),
          agentName: z.string(),
        })
        .describe("The target agent to message"),
      content: z.string().describe("The message content to send"),
    }),
  },
  noOutput: {
    name: "noOutput",
    description: "Use this tool if you dont want to return any output",
    parameters: z.object({
      reasoning: z.string().describe("The reason for not returning output"),
    }),
  },
  webSearch: {
    name: "webSearch",
    description: "Use this tool to search the web for information",
    parameters: z.object({
      query: z.string().describe("The search query to execute"),
    }),
  },
  scheduleTask: {
    name: "scheduleTask",
    description: "Allows scheduling of a task to be completed at a later time.",
    parameters: z.object({
      target: z
        .object({
          agentId: z.string(),
          agentName: z.string(),
        })
        .describe("The target agent for the scheduled task"),
      title: z.string().describe("The title of the scheduled task"),
      content: z.string().describe("The content of the scheduled task"),
      secondsFromNow: z
        .number()
        .describe("When to schedule the task for (in seconds from now)"),
    }),
  },
  updateConversationTitle: {
    name: "updateConversationTitle",
    description:
      "Updates the title of the current conversation to better reflect its content",
    parameters: z.object({
      title: z.string().describe("The new title for the conversation"),
    }),
  },
  sendEmail: {
    name: "sendEmail",
    description: "Sends an email using Resend",
    parameters: z.object({
      to: z.string().describe("The email address to send to"),
      subject: z.string().describe("The subject of the email"),
      content: z.string().describe("The HTML content of the email"),
      from: z
        .string()
        .optional()
        .describe("Optional from address, defaults to the system default"),
    }),
  },
  addParticipantToConversation: {
    name: "addParticipantToConversation",
    description: "Adds an agent to the current conversation",
    parameters: z.object({
      agentId: z
        .string()
        .describe("The ID of the agent to add to the conversation"),
    }),
  },
} as const;

export type AgentToolName = keyof typeof toolDefinitions;

// Define the subset of tools that users can choose from
export const userChoosableToolDefinitions = pick(toolDefinitions, [
  "webSearch",
  "scheduleTask",
  "sendEmail",
]);

export type UserChoosableToolName = keyof typeof userChoosableToolDefinitions;

export const alwaysIncludedTools = pick(toolDefinitions, [
  "listConversationParticipants",
  "listAgents",
  "messageAnotherAgent",
  "noOutput",
  "updateConversationTitle",
  "addParticipantToConversation",
]);

export type AlwaysIncludedToolName = keyof typeof alwaysIncludedTools;
</file>

<file path="src/components/authenticated/chat/ParticipantsDialog.tsx">
import * as React from "react";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Doc, Id } from "../../../../convex/_generated/dataModel";
import { Avatar, AvatarFallback, AvatarImage } from "../../ui/avatar";
import { Button } from "../../ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "../../ui/dialog";
import { UserPlus, Trash2 } from "lucide-react";
import { AgentSelector } from "./AgentSelector";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "../../ui/tooltip";

interface ParticipantsDialogProps {
  conversation: Doc<"conversations">;
  trigger: React.ReactNode;
}

export const ParticipantsDialog: React.FC<ParticipantsDialogProps> = ({
  conversation,
  trigger,
}) => {
  const participants = useQuery(
    api.conversationParticipants.queries.listDetailsForMe,
    {
      conversationId: conversation._id,
    },
  );

  const removeParticipant = useMutation(
    api.conversationParticipants.mutations.removeParticipant,
  );

  const handleRemove = async (
    participantId: Id<"conversationParticipants">,
  ) => {
    await removeParticipant({
      conversationId: conversation._id,
      participantId,
    });
  };

  // Group participants by type
  const users = participants?.filter((p) => p.kind === "user") ?? [];
  const agents = participants?.filter((p) => p.kind === "agent") ?? [];

  return (
    <Dialog>
      <DialogTrigger asChild>{trigger}</DialogTrigger>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>Conversation Participants</DialogTitle>
        </DialogHeader>
        <div className="space-y-6">
          {/* Users section */}
          <div className="space-y-2">
            <div className="text-sm font-medium text-muted-foreground">
              Users
            </div>
            {users.map((p) => (
              <div
                key={p.id}
                className="flex items-center justify-between p-2 rounded-lg hover:bg-muted"
              >
                <div className="flex items-center gap-3">
                  <Avatar>
                    <AvatarImage src={p.avatarUrl} />
                    <AvatarFallback>{p.name[0]}</AvatarFallback>
                  </Avatar>
                  <div>
                    <div className="font-medium">{p.name}</div>
                    {p.isCreator && (
                      <div className="text-xs text-muted-foreground">
                        Creator
                      </div>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>

          {/* Agents section */}
          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <div className="text-sm font-medium text-muted-foreground">
                Agents
              </div>
              <AgentSelector
                conversation={conversation}
                trigger={
                  <Button variant="ghost" size="sm" className="h-7">
                    <UserPlus className="h-4 w-4 mr-1.5" />
                    Add
                  </Button>
                }
              />
            </div>
            {agents.map((p) => (
              <div
                key={p.id}
                className="flex items-center justify-between p-2 rounded-lg hover:bg-muted"
              >
                <div className="flex items-center gap-3">
                  <Avatar>
                    <AvatarImage src={p.avatarUrl} />
                    <AvatarFallback>{p.name[0]}</AvatarFallback>
                  </Avatar>
                  <div>
                    <div className="font-medium">{p.name}</div>
                    <div className="text-sm text-muted-foreground">
                      {p.description}
                    </div>
                  </div>
                </div>
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <div>
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => handleRemove(p.id)}
                          disabled={p.isSystem}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </TooltipTrigger>
                    {p.isSystem && (
                      <TooltipContent>
                        <p>
                          System agents cannot be removed from a conversation
                        </p>
                      </TooltipContent>
                    )}
                  </Tooltip>
                </TooltipProvider>
              </div>
            ))}
            {agents.length === 0 && (
              <div className="text-sm text-muted-foreground text-center py-4 bg-muted/50 rounded-lg">
                No agents added yet
              </div>
            )}
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="src/components/authenticated/AuthenticatedContent.tsx">
import * as React from "react";
import { ChatArea } from "./chat/ChatArea";
import { Sidebar } from "./sidebar/Sidebar";
import { useRoute, routes, useCurrentConversationId } from "../../routes";
import { Id } from "convex/_generated/dataModel";
import { AgentProfile } from "./agents/AgentProfile";

interface Message {
  id: string;
  content: string;
  sender: "user" | "agent";
  timestamp: string;
  agentName?: string;
}

export const AuthenticatedContent: React.FC = () => {
  const route = useRoute();
  const currentConversationId = useCurrentConversationId();

  // If we're not in a conversation or agent view, show a welcome message
  if (!currentConversationId && route.name !== "agent")
    return (
      <div className="h-screen flex bg-background">
        <div className="w-64 bg-card border-r border-border flex flex-col dark">
          <Sidebar />
        </div>
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <h1 className="text-2xl font-bold mb-4">Welcome to Agent Inbox</h1>
            <p className="text-muted-foreground">
              Select a conversation or agent to get started
            </p>
          </div>
        </div>
      </div>
    );

  return (
    <div className="h-screen flex overflow-hidden bg-background">
      <div className="w-64 bg-card border-r border-border flex-shrink-0 dark">
        <Sidebar />
      </div>

      <div className="flex-1 overflow-auto">
        {route.name === "conversation" ? (
          <ChatArea
            conversationId={route.params.conversationId as Id<"conversations">}
          />
        ) : null}

        {route.name === "agent" ? (
          <AgentProfile agentId={route.params.agentId as Id<"agents">} />
        ) : null}
      </div>
    </div>
  );
};
</file>

<file path="src/components/authenticated/sidebar/AgentList.tsx">
import * as React from "react";
import { Button } from "../../ui/button";
import { Plus } from "lucide-react";
import { useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { useApiErrorHandler } from "../../misc/errors";
import { Id } from "../../../../convex/_generated/dataModel";
import { useQuery } from "convex-helpers/react/cache";
import { routes, useCurrentAgentId } from "../../../routes";
import { AgentAvatar } from "@/components/ui/agent-avatar";

type Agent = {
  _id: Id<"agents">;
  name: string;
  description: string;
  status: "idle" | "active" | "processing";
  avatarUrl: string;
};

export const AgentList = () => {
  const agents = useQuery(api.agents.queries.listMine);
  const createAgent = useMutation(api.agents.mutations.create);
  const onApiError = useApiErrorHandler();
  const currentAgentId = useCurrentAgentId();

  return (
    <>
      <div className="p-4">
        <Button
          className="w-full"
          variant="default"
          onClick={() =>
            createAgent()
              .then((agentId) => routes.agent({ agentId }).push())
              .catch(onApiError)
          }
        >
          <Plus className="h-5 w-5" />
          New Agent
        </Button>
      </div>
      <div className="flex-1 overflow-y-auto">
        {agents?.map((agent) => (
          <div
            key={agent._id}
            onClick={() => routes.agent({ agentId: agent._id }).push()}
            className={`p-4 cursor-pointer hover:bg-accent flex items-center gap-3 ${
              agent._id === currentAgentId ? "bg-accent" : ""
            }`}
          >
            <AgentAvatar
              size="sm"
              avatarUrl={agent.avatarUrl}
              name={agent.name}
            />
            <div className="min-w-0 flex-1">
              <div className="font-medium text-primary-foreground truncate">
                {agent.name}
              </div>
              <div className="text-sm text-muted-foreground truncate">
                {agent.description}
              </div>
            </div>
          </div>
        ))}
      </div>
    </>
  );
};
</file>

<file path="convex/conversations/model.ts">
import {
  DatabaseReader,
  DatabaseWriter,
  MutationCtx,
  QueryCtx,
} from "../_generated/server";
import { Id } from "../_generated/dataModel";
import * as Users from "../users/model";
import * as ConversationParticipants from "../conversationParticipants/model";
import * as Agents from "../agents/model";
import { doesHaveTriageAgent } from "../conversationParticipants/model";
import * as ConversationMessages from "../conversationMessages/model";

export const ensureICanAccessConversation = async (
  ctx: QueryCtx | MutationCtx,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const userId = await Users.getMyId(ctx);
  const conversation = await ctx.db.get(conversationId);

  if (!conversation) throw new Error("Conversation not found");
  if (conversation.createdBy !== userId) throw new Error("Access denied");

  return conversation;
};

export const createConversation = async (
  ctx: MutationCtx,
  { title }: { title: string },
) => {
  const userId = await Users.getMyId(ctx);
  const conversationId = await ctx.db.insert("conversations", {
    title,
    createdBy: userId,
    lastMessageTime: Date.now(),
  });

  // Add the creator as a participant
  await ConversationParticipants.addUser(ctx.db, { conversationId, userId });

  return conversationId;
};

export const listMine = async (ctx: QueryCtx) => {
  const userId = await Users.getMyId(ctx);

  return await ctx.db
    .query("conversations")
    .withIndex("by_user_and_time", (q) => q.eq("createdBy", userId))
    .order("desc")
    .collect();
};

export const findMine = async (
  ctx: QueryCtx,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const userId = await Users.getMyId(ctx);
  const conversation = await ctx.db.get(conversationId);
  if (conversation && conversation.createdBy !== userId)
    throw new Error("Access denied");
  return conversation;
};

export const getMine = async (
  ctx: QueryCtx,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const conversation = await findMine(ctx, { conversationId });
  if (!conversation) throw new Error("Conversation not found");
  return conversation;
};

export const update = async (
  ctx: MutationCtx,
  {
    conversationId,
    title,
  }: { conversationId: Id<"conversations">; title: string },
) => {
  return await ctx.db.patch(conversationId, { title });
};

export const updateMine = async (
  ctx: MutationCtx,
  {
    conversationId,
    title,
  }: { conversationId: Id<"conversations">; title: string },
) => {
  await ensureICanAccessConversation(ctx, { conversationId });
  return update(ctx, { conversationId, title });
};

export const removeMine = async (
  ctx: MutationCtx,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  await ensureICanAccessConversation(ctx, { conversationId });

  // Delete all messages and participants first
  await ConversationMessages.deleteAllMessagesForConversation(ctx.db, {
    conversationId,
  });

  await ConversationParticipants.deleteAllParticipantsForConversation(ctx.db, {
    conversationId,
  });

  // Finally delete the conversation itself
  await ctx.db.delete(conversationId);
};

export const isTriageAgentJoined = async (
  db: DatabaseReader,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  return await doesHaveTriageAgent(db, { conversationId });
};

export const joinTriageAgentToConversationIfNotAlreadyJoined = async (
  db: DatabaseWriter,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const agent = await Agents.getSystemAgentByKind(db, {
    systemAgentKind: "triage",
  });
  const conversation = await db.get(conversationId);
  if (!conversation)
    throw new Error(`Conversation not found ${conversationId}`);

  // If we have the triage agent in the conversation then we can return that
  const triageAgent = await Agents.getTriageAgent(db);
  const triageAgentParticipant =
    await ConversationParticipants.findParticipantByConversationIdAndIdentifier(
      db,
      {
        conversationId,
        identifier: {
          kind: "agent",
          agentId: triageAgent._id,
        },
      },
    );
  if (triageAgentParticipant) return triageAgentParticipant;

  // Otherwise we add the triage agent to the conversation
  const participantId = await ConversationParticipants.addAgentOrReactivate(
    db,
    {
      conversationId,
      agentId: agent._id,
    },
  );

  // We also create a message to notify the user that the triage agent has joined the conversation
  await ConversationMessages.createParticipantJoinedConversationMessage(db, {
    conversationId,
    agentOrUser: triageAgent,
  });

  return ConversationParticipants.getParticipant(db, { participantId });
};

export const joinAgentToConversationIfNotAlreadyJoined = async (
  db: DatabaseWriter,
  {
    conversationId,
    agentId,
  }: { conversationId: Id<"conversations">; agentId: Id<"agents"> },
) => {
  const agent = await db.get(agentId);
  if (!agent) throw new Error(`Agent of id '${agentId}' could not be found`);

  const conversation = await db.get(conversationId);
  if (!conversation)
    throw new Error(
      `Conversation of id '${conversationId}' could not be found`,
    );

  // Check if the agent is already a participant in the conversation
  const existingParticipant =
    await ConversationParticipants.findParticipantByConversationIdAndIdentifier(
      db,
      {
        conversationId,
        identifier: {
          kind: "agent",
          agentId,
        },
      },
    );

  if (existingParticipant) return existingParticipant;

  // Add the agent to the conversation
  const participantId = await ConversationParticipants.addAgentOrReactivate(
    db,
    {
      conversationId,
      agentId,
    },
  );

  // Create a message to notify that the agent has joined the conversation
  await ConversationMessages.createParticipantJoinedConversationMessage(db, {
    conversationId,
    agentOrUser: agent,
  });

  return ConversationParticipants.getParticipant(db, { participantId });
};
</file>

<file path="convex/ai/agentReplyToMessage.ts">
"use node";
import { Doc } from "../_generated/dataModel";
import { openai } from "@ai-sdk/openai";
import { Id } from "../_generated/dataModel";
import { ActionCtx } from "../_generated/server";
import { internal } from "../_generated/api";
import { createToolsForAgent } from "./tools";
import { generateText } from "ai";
import { constructAgentReplyInstructions } from "./instructions";
import { ParticipantUserOrAgent } from "../conversationParticipants/model";
import { gatherMessages } from "./messages";
import {
  getAgentAndEnsureItIsJoinedToConversation,
  runAgentAIGeneration,
  processAgentAIResult,
} from "./utils";

export const agentReplyToMessage = async (
  ctx: ActionCtx,
  args: {
    message: Doc<"conversationMessages">;
    agentId: Id<"agents">;
    conversation: Doc<"conversations">;
    messageAuthor: ParticipantUserOrAgent;
  },
) => {
  const { agent, participant } =
    await getAgentAndEnsureItIsJoinedToConversation(ctx, {
      agentId: args.agentId,
      conversationId: args.message.conversationId,
    });

  if (participant.kind !== "agent")
    throw new Error(
      `Participant of id '${participant._id}' is not an agent, but is of kind '${participant.kind}'`,
    );

  await runAgentAIGeneration(ctx, {
    agent,
    participant,
    conversation: args.conversation,
    generateAIResponse: async () => {
      const result = await generateText({
        model: openai("gpt-4o"),
        tools: createToolsForAgent({
          ctx,
          agent,
          agentParticipant: participant,
          conversation: args.conversation,
        }),
        maxSteps: 10,
        messages: await gatherMessages(ctx, {
          systemMessage: constructAgentReplyInstructions({
            conversation: args.conversation,
            messageAuthor: args.messageAuthor,
            agent,
          }),
          conversation: args.conversation,
          message: args.message,
          messageAuthor: args.messageAuthor,
        }),
      });

      await processAgentAIResult(ctx, {
        result,
        agent,
        conversation: args.conversation,
        participant,
        sendMessage: async (text) => {
          await ctx.runMutation(
            internal.conversationMessages.internalMutations.sendFromAgent,
            {
              conversationId: args.message.conversationId,
              agentId: agent._id,
              content: text,
              authorParticipantId: participant._id,
            },
          );
        },
      });

      return result;
    },
  });
};
</file>

<file path="convex/schema.ts">
import { defineSchema, defineTable } from "convex/server";
import { authTables } from "@convex-dev/auth/server";
import { v } from "convex/values";
import { agentsSchemaValidator } from "./agents/schema";
import { conversationParticipantsTable } from "./conversationParticipants/schema";
import { conversationMessagesTable } from "./conversationMessages/schema";

// The schema is normally optional, but Convex Auth
// requires indexes defined on `authTables`.
// The schema provides more precise TypeScript types.
export default defineSchema({
  ...authTables,

  conversations: defineTable({
    title: v.string(),
    createdBy: v.id("users"),
    lastMessageTime: v.number(),
  }).index("by_user_and_time", ["createdBy", "lastMessageTime"]),

  agents: defineTable(agentsSchemaValidator)
    .index("by_creator", ["createdBy"])
    .index("by_name", ["name"])
    .index("by_system_agent_kind", ["systemAgentKind"]),

  conversationParticipants: conversationParticipantsTable,
  conversationMessages: conversationMessagesTable,
});
</file>

<file path="src/components/authenticated/chat/ParticipantMessage.tsx">
import * as React from "react";
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useTimeAgo } from "@/components/misc/hooks";
import { useQuery } from "convex/react";
import { Doc, Id } from "convex/_generated/dataModel";
import { api } from "../../../../convex/_generated/api";
import { AgentMention } from "./AgentMention";
import { UserMention } from "./UserMention";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { splitMessageContent } from "../../../../shared/mentions";
import { ReplyIcon } from "lucide-react";
import { createMentionString } from "../../../../shared/mentions";
import { useChatContext } from "./ChatContext";
import { Button } from "@/components/ui/button";

interface Props {
  message: Doc<"conversationMessages">;
}

export const ParticipantMessage: React.FC<Props> = ({ message }) => {
  if (message.kind != "participant")
    throw new Error("Message is not a participant message");

  const { setReplyToMention, setShouldFocusInput } = useChatContext();
  const [isHovered, setIsHovered] = React.useState(false);

  const participants = useQuery(
    api.conversationParticipants.queries.listDetailsForMe,
    {
      conversationId: message.conversationId,
    },
  );

  const participant = participants?.find(
    (p) => p.id === message.authorParticipantId,
  );

  // Get all agents to find the matching one for this participant
  const agents = useQuery(api.agents.queries.listMine);
  const matchingAgent =
    participant?.kind === "agent" &&
    agents?.find((agent) => agent.name === participant.name);

  const timeAgo = useTimeAgo(message._creationTime);

  const handleReply = () => {
    if (participant?.kind === "agent" && matchingAgent) {
      const mentionText = createMentionString({
        kind: "agent",
        agentId: matchingAgent._id,
        name: participant.name ?? "Agent",
      });
      setReplyToMention(mentionText + " ");
      setShouldFocusInput(true);
    }
  };

  const renderMessageContent = (content: string) => {
    const parts = splitMessageContent(content);

    return parts.map((part, index) => {
      if (part.type === "text") {
        return (
          <ReactMarkdown
            key={index}
            remarkPlugins={[remarkGfm]}
            components={{
              // Ensure links open in new tab
              a: (props) => (
                <a
                  {...props}
                  target="_blank"
                  rel="noopener noreferrer"
                  className={`${
                    participant?.kind === "user"
                      ? "text-primary-foreground  decoration-primary-foreground/70 hover:decoration-primary-foreground hover:text-orange-200"
                      : "text-blue-600 dark:text-blue-400 font-medium  decoration-blue-600/70 dark:decoration-blue-400/70 hover:text-orange-500 dark:hover:text-orange-400"
                  } transition-all`}
                />
              ),
              // Preserve the styling of your messages
              p: (props) => <span {...props} />,
            }}
          >
            {part.content}
          </ReactMarkdown>
        );
      } else {
        const reference = part.reference;
        if (reference.kind === "agent") {
          return (
            <AgentMention
              key={`mention-${index}`}
              display={reference.display}
              agentId={reference.agentId}
              isInUserMessage={participant?.kind === "user"}
            />
          );
        } else {
          return (
            <UserMention
              key={`mention-${index}`}
              display={reference.display}
              userId={reference.userId}
              isInUserMessage={participant?.kind === "user"}
            />
          );
        }
      }
    });
  };

  return (
    <div
      className={`flex items-start gap-3 ${
        participant?.kind === "user" ? "flex-row-reverse" : "flex-row"
      }`}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <Avatar className="mt-1">
              <AvatarImage src={participant?.avatarUrl} />
              <AvatarFallback>
                {participant?.kind === "user"
                  ? "U"
                  : participant?.name?.[0] ?? "A"}
              </AvatarFallback>
            </Avatar>
          </TooltipTrigger>
          <TooltipContent>
            {participant?.kind === "user"
              ? "You"
              : participant?.name ?? "Agent"}
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
      <div className="relative max-w-[70%]">
        <div
          className={`rounded-lg p-3 ${
            participant?.kind === "user"
              ? "bg-primary text-primary-foreground"
              : "bg-muted"
          }`}
        >
          {participant?.kind === "agent" && (
            <div className="text-sm font-medium text-foreground mb-1">
              {participant.name}
            </div>
          )}
          <div className="space-x-1">
            {renderMessageContent(message.content)}
          </div>
          <div
            className={`text-xs mt-1 ${
              participant?.kind === "user"
                ? "text-primary-foreground/80"
                : "text-muted-foreground"
            }`}
          >
            {timeAgo}
          </div>
        </div>

        {participant?.kind === "agent" && matchingAgent && isHovered && (
          <Button
            onClick={handleReply}
            variant="ghost"
            size="icon"
            className="absolute -right-10 top-1/2 -translate-y-1/2 hover:bg-accent rounded-full"
            aria-label="Reply to agent"
          >
            <ReplyIcon className="h-4 w-4" />
          </Button>
        )}
      </div>
    </div>
  );
};
</file>

<file path="convex/ai/triageMessage.ts">
"use node";
import { ActionCtx } from "../_generated/server";
import { internal } from "../_generated/api";
import { Doc } from "../_generated/dataModel";
import { openai } from "@ai-sdk/openai";
import { createToolsForAgent } from "./tools";
import { generateText } from "ai";
import { ParticipantUserOrAgent } from "../conversationParticipants/model";
import { constructTriageInstructions } from "./instructions";
import {
  getTriageAgentAndEnsureItIsJoinedToConversation,
  runAgentAIGeneration,
  processAgentAIResult,
} from "./utils";
import { gatherMessages } from "./messages";

export const triageMessage = async (
  ctx: ActionCtx,
  args: {
    message: Doc<"conversationMessages">;
    messageAuthor: ParticipantUserOrAgent;
    conversation: Doc<"conversations">;
  },
) => {
  const { agent, participant } =
    await getTriageAgentAndEnsureItIsJoinedToConversation(
      ctx,
      args.conversation._id,
    );

  if (participant.kind !== "agent")
    throw new Error(
      `Participant of id '${participant._id}' is not an agent, but is of kind '${participant.kind}'`,
    );

  await runAgentAIGeneration(ctx, {
    agent,
    participant,
    conversation: args.conversation,
    generateAIResponse: async () => {
      const result = await generateText({
        model: openai("gpt-4o"),
        tools: createToolsForAgent({
          ctx,
          agent,
          agentParticipant: participant,
          conversation: args.conversation,
        }),
        maxSteps: 20,
        messages: await gatherMessages(ctx, {
          systemMessage: constructTriageInstructions({
            conversation: args.conversation,
            messageAuthor: args.messageAuthor,
            agent,
          }),
          conversation: args.conversation,
          message: args.message,
          messageAuthor: args.messageAuthor,
        }),
      });

      await processAgentAIResult(ctx, {
        result,
        agent,
        conversation: args.conversation,
        participant,
        sendMessage: async (text) => {
          await ctx.runMutation(
            internal.conversationMessages.internalMutations.sendFromTriageAgent,
            {
              conversationId: args.conversation._id,
              content: text,
            },
          );
        },
      });

      return result;
    },
  });
};
</file>

<file path="src/components/authenticated/agents/AgentProfile.tsx">
import * as React from "react";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";
import { useApiErrorHandler } from "@/components/misc/errors";
import { routes } from "@/routes";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { Confirm } from "@/components/ui/confirm";
import { AgentAvatar } from "@/components/ui/agent-avatar";
import { AgentDescription } from "./AgentDescription";
import { AgentPersonality } from "./AgentPersonality";
import { AgentTools } from "./AgentTools";
import { Loader2, Shuffle, Pencil, Check } from "lucide-react";
import { Input } from "@/components/ui/input";
import { AgentToolName } from "../../../../shared/tools";

export const AgentProfile = ({ agentId }: { agentId: Id<"agents"> }) => {
  const agent = useQuery(api.agents.queries.findMine, { agentId });
  const deleteAgent = useMutation(api.agents.mutations.removeMine);
  const shuffleAvatar = useMutation(api.agents.mutations.shuffleAvatar);
  const updateAgent = useMutation(api.agents.mutations.updateMine);
  const [showDeleteConfirm, setShowDeleteConfirm] = React.useState(false);
  const [isEditingName, setIsEditingName] = React.useState(false);
  const [editedName, setEditedName] = React.useState("");
  const [isShufflingAvatar, setIsShufflingAvatar] = React.useState(false);
  const onApiError = useApiErrorHandler();

  React.useEffect(() => {
    if (agent?.name) setEditedName(agent.name);
  }, [agent?.name]);

  const handleNameSubmit = async () => {
    if (!editedName.trim() || editedName === agent?.name) {
      setIsEditingName(false);
      return;
    }

    if (!agent) return;

    await updateAgent({
      agentId,
      name: editedName,
      description: agent.description,
      personality: agent.personality,
      tools: agent.tools,
    })
      .catch(onApiError)
      .finally(() => setIsEditingName(false));
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      handleNameSubmit();
    } else if (e.key === "Escape") {
      setIsEditingName(false);
      setEditedName(agent?.name ?? "");
    }
  };

  if (!agent)
    return (
      <div className="flex-1 p-8">
        <div className="max-w-2xl mx-auto space-y-6">
          <Skeleton className="h-48 w-48 rounded-full mx-auto" />
          <Skeleton className="h-8 w-48 mx-auto" />
          <Skeleton className="h-24 w-full" />
          <div className="grid grid-cols-2 gap-4">
            <Skeleton className="h-32" />
            <Skeleton className="h-32" />
          </div>
        </div>
      </div>
    );

  return (
    <div className="flex-1 p-8">
      <div className="max-w-2xl mx-auto space-y-8">
        <div className="text-center">
          <div className="relative inline-block">
            <AgentAvatar
              avatarUrl={agent.avatarUrl}
              name={agent.name}
              size="lg"
            />
            <Button
              variant="secondary"
              size="icon"
              className="absolute bottom-6 -right-2"
              disabled={isShufflingAvatar}
              onClick={async () => {
                setIsShufflingAvatar(true);
                await shuffleAvatar({
                  agentId,
                })
                  .catch(onApiError)
                  .finally(() => setIsShufflingAvatar(false));
              }}
            >
              {isShufflingAvatar ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <Shuffle className="h-4 w-4" />
              )}
            </Button>
          </div>
          <div className="flex items-center justify-center gap-2 mb-2">
            {isEditingName ? (
              <div className="flex items-center gap-2">
                <Input
                  value={editedName}
                  onChange={(e) => setEditedName(e.target.value)}
                  onKeyDown={handleKeyDown}
                  className="text-2xl font-bold text-center w-64"
                  autoFocus
                />
                <Button variant="ghost" size="icon" onClick={handleNameSubmit}>
                  <Check className="h-4 w-4" />
                </Button>
              </div>
            ) : (
              <>
                <h1 className="text-3xl font-bold">{agent.name}</h1>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() => setIsEditingName(true)}
                >
                  <Pencil className="h-4 w-4" />
                </Button>
              </>
            )}
          </div>
        </div>
        <AgentDescription
          agentId={agent._id}
          name={agent.name}
          description={agent.description}
          personality={agent.personality}
          tools={agent.tools}
        />
        <div className="grid grid-cols-2 gap-6">
          <AgentPersonality
            agentId={agent._id}
            name={agent.name}
            description={agent.description}
            personality={agent.personality}
            tools={agent.tools}
          />
          <AgentTools
            agentId={agent._id}
            name={agent.name}
            description={agent.description}
            personality={agent.personality}
            tools={agent.tools as AgentToolName[]}
          />
        </div>
        <div className="text-sm text-muted-foreground text-center">
          Last active: {new Date(agent.lastActiveTime).toLocaleString()}
        </div>
        <div className="flex justify-center">
          <Button
            variant="destructive"
            onClick={() => setShowDeleteConfirm(true)}
          >
            Delete Agent
          </Button>
        </div>

        <Confirm
          open={showDeleteConfirm}
          onOpenChange={setShowDeleteConfirm}
          title="Delete Agent"
          description={`Are you sure you want to delete ${agent.name}? This action cannot be undone.`}
          confirmText="Delete"
          cancelText="Cancel"
          onConfirm={() =>
            deleteAgent({ agentId: agent._id })
              .then(() => routes.home().push())
              .catch(onApiError)
          }
          variant="destructive"
        />
      </div>
    </div>
  );
};
</file>

<file path="src/components/authenticated/chat/ChatInput.tsx">
import * as React from "react";
import { MentionsInput, Mention, SuggestionDataItem } from "react-mentions";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";
import { AgentAvatar } from "@/components/ui/agent-avatar";
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";
import { useApiErrorHandler } from "@/components/misc/errors";
import { ReactNode } from "react";
import { useChatContext } from "./ChatContext";

// Define our custom suggestion data type
interface CustomSuggestionData extends SuggestionDataItem {
  type: "agent" | "user";
  avatarUrl?: string;
  display: string;
}

interface ChatInputProps {
  conversationId: Id<"conversations">;
}

export const ChatInput: React.FC<ChatInputProps> = ({ conversationId }) => {
  const [message, setMessage] = React.useState("");
  const agents = useQuery(api.agents.queries.listMine) ?? [];
  const sendMessage = useMutation(
    api.conversationMessages.mutations.sendFromMe,
  );
  const apiError = useApiErrorHandler();
  const {
    replyToMention,
    setReplyToMention,
    shouldFocusInput,
    setShouldFocusInput,
  } = useChatContext();
  const mentionsRef = React.useRef<HTMLDivElement>(null);

  // Apply the reply mention when it changes
  React.useEffect(() => {
    if (replyToMention) {
      setMessage(replyToMention);
      setReplyToMention(null); // Clear after applying
    }
  }, [replyToMention, setReplyToMention]);

  // Handle focus when triggered
  React.useEffect(() => {
    if (shouldFocusInput && mentionsRef.current) {
      // Focus the input element inside the mentions wrapper
      const input =
        mentionsRef.current.querySelector("textarea") ||
        mentionsRef.current.querySelector("input");
      if (input) {
        input.focus();
        setShouldFocusInput(false);
      }
    }
  }, [shouldFocusInput, setShouldFocusInput]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!message.trim()) return;

    setMessage("");

    await sendMessage({
      content: message,
      conversationId: conversationId,
    }).catch(apiError);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e);
    }
  };

  const suggestions: CustomSuggestionData[] = [
    ...agents.map((agent) => ({
      id: `agent:${agent._id}`,
      display: agent.name ?? "",
      type: "agent" as const,
      avatarUrl: agent.avatarUrl,
    })),
  ];

  return (
    <div className="p-4 sticky bottom-0 z-10">
      <form
        onSubmit={handleSubmit}
        className="flex gap-2 bg-card shadow-lg p-2 rounded-lg border border-border"
      >
        <div className="flex-1 min-w-0" ref={mentionsRef}>
          <MentionsInput
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            onKeyDown={handleKeyDown}
            className="mentions"
            style={{
              control: {
                backgroundColor: "transparent",
                fontSize: 16,
                fontWeight: "normal",
              },
              input: {
                margin: 0,
                padding: "8px 12px",
                overflow: "auto",
                minHeight: "40px",
                maxHeight: "120px",
                border: "none",
                borderRadius: 6,
                backgroundColor: "transparent",
                color: "inherit",
                outline: "none",
              },
              suggestions: {
                list: {
                  backgroundColor: "var(--background)",
                  border: "1px solid var(--border)",
                  borderRadius: "0.375rem",
                  boxShadow: "0 2px 8px rgba(0, 0, 0, 0.1)",
                  fontSize: "14px",
                  maxHeight: "300px",
                  overflow: "auto",
                  width: "300px",
                  minWidth: "100%",
                  position: "absolute" as const,
                  bottom: "100%",
                  left: 0,
                  right: 0,
                  marginBottom: "0.5rem",
                  zIndex: 1000,
                },
                item: {
                  padding: "8px 12px",
                  borderBottom: "1px solid var(--border)",
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  cursor: "pointer",
                  transition: "background-color 0.2s",
                  whiteSpace: "nowrap",
                  overflow: "hidden",
                  "&focused": {
                    backgroundColor: "var(--accent)",
                  },
                },
              },
            }}
            placeholder="Type a message... Use @ to mention agents or users"
            singleLine={false}
            allowSpaceInQuery={true}
          >
            <Mention
              trigger="@"
              data={suggestions}
              displayTransform={(id, display) => `@${display}`}
              markup="@[__display__](__id__)"
              appendSpaceOnAdd={true}
              style={{
                backgroundColor: "var(--accent)",
                borderRadius: "6px",
              }}
              renderSuggestion={
                ((
                  suggestion: CustomSuggestionData,
                  search: string,
                  highlightedDisplay: ReactNode,
                ) => (
                  <div className="flex items-center gap-2 p-0 hover:bg-accent cursor-pointer">
                    {suggestion.type === "agent" ? (
                      <AgentAvatar
                        size="sm"
                        avatarUrl={suggestion.avatarUrl ?? ""}
                        name={suggestion.display}
                      />
                    ) : (
                      <Avatar className="h-6 w-6">
                        <AvatarImage src={suggestion.avatarUrl} />
                        <AvatarFallback>
                          {(suggestion.display?.[0] ?? "U").toUpperCase()}
                        </AvatarFallback>
                      </Avatar>
                    )}
                    <span>{highlightedDisplay}</span>
                  </div>
                )) as any
              }
            />
          </MentionsInput>
        </div>
        <button
          type="submit"
          className="bg-primary text-primary-foreground px-4 py-2 rounded-md hover:bg-primary/90"
        >
          Send
        </button>
      </form>

      <style>
        {`
        .mentions {
          width: 100%;
        }
        .mentions--focused {
          outline: none;
        }
        .mentions__suggestions__list {
          background-color: var(--background);
          border: 1px solid var(--border);
          border-radius: 6px;
          margin-top: 8px;
          position: absolute;
          bottom: 100%;
          left: 0;
          right: 0;
          z-index: 10;
        }
        .mentions__suggestions__item {
          padding: 8px;
          cursor: pointer;
        }
        .mentions__suggestions__item--focused {
          background-color: var(--accent);
        }
        .mentions__highlighter {
          padding: 8px 12px;
          overflow: hidden;
        }
        `}
      </style>
    </div>
  );
};
</file>

<file path="convex/conversationParticipants/model.ts">
import { DatabaseReader, DatabaseWriter, QueryCtx } from "../_generated/server";
import { Doc, Id } from "../_generated/dataModel";
import * as Agents from "../agents/model";
import * as Users from "../users/model";
import { exhaustiveCheck } from "../../shared/misc";
import { conversationParticipantIdentifierSchemaValidator } from "./schema";
import * as ConversationMessages from "../conversationMessages/model";
import { get } from "../agents/model";

export const getNonRemovedParticipants = async (
  db: DatabaseReader,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const participants = await db
    .query("conversationParticipants")
    .withIndex("by_conversationId_isRemoved", (q) =>
      q.eq("conversationId", conversationId).eq("isRemoved", false),
    )
    .collect();

  return participants;
};

export const findParticipant = async (
  db: DatabaseReader,
  { participantId }: { participantId: Id<"conversationParticipants"> },
) => {
  return await db.get(participantId);
};

export const getParticipant = async (
  db: DatabaseReader,
  { participantId }: { participantId: Id<"conversationParticipants"> },
) => {
  const participant = await findParticipant(db, { participantId });
  if (!participant) throw new Error(`Participant not found ${participantId}`);
  return participant;
};

export const getParticipantUserOrAgent = async (
  db: DatabaseReader,
  { participantId }: { participantId: Id<"conversationParticipants"> },
): Promise<
  { kind: "agent"; agent: Doc<"agents"> } | { kind: "user"; user: Doc<"users"> }
> => {
  const participant = await getParticipant(db, { participantId });

  if (participant.kind === "agent")
    return {
      kind: "agent" as const,
      agent: await Agents.get(db, { agentId: participant.agentId }),
    };

  if (participant.kind === "user")
    return {
      kind: "user",
      user: await Users.get(db, { userId: participant.userId }),
    };

  exhaustiveCheck(participant);
};
export type ParticipantUserOrAgent = Awaited<
  ReturnType<typeof getParticipantUserOrAgent>
>;

export const addAgentOrReactivate = async (
  db: DatabaseWriter,
  {
    conversationId,
    agentId,
  }: { conversationId: Id<"conversations">; agentId: Id<"agents"> },
) => {
  const existing = await db
    .query("conversationParticipants")
    .withIndex("by_conversationId_kind_agentId", (q) =>
      q
        .eq("conversationId", conversationId)
        .eq("kind", "agent")
        .eq("agentId", agentId),
    )
    .first();

  if (existing) {
    if (existing.isRemoved)
      await db.patch(existing._id, {
        isRemoved: false,
      });

    return existing._id;
  }

  return db.insert("conversationParticipants", {
    conversationId,
    agentId,
    kind: "agent",
    addedAt: Date.now(),
    status: "inactive",
    isRemoved: false,
  });
};

export const addAgentAndSendJoinMessage = async (
  db: DatabaseWriter,
  {
    conversationId,
    agentId,
  }: { conversationId: Id<"conversations">; agentId: Id<"agents"> },
) => {
  const participantId = await addAgentOrReactivate(db, {
    conversationId,
    agentId,
  });
  const agent = await Agents.get(db, { agentId });
  await ConversationMessages.createParticipantJoinedConversationMessage(db, {
    conversationId,
    agentOrUser: agent,
  });
  return participantId;
};

export const addUser = async (
  db: DatabaseWriter,
  {
    conversationId,
    userId,
  }: { conversationId: Id<"conversations">; userId: Id<"users"> },
) => {
  const existing = await db
    .query("conversationParticipants")
    .withIndex("by_conversationId_kind_userId", (q) =>
      q
        .eq("conversationId", conversationId)
        .eq("kind", "user")
        .eq("userId", userId),
    )
    .first();

  if (existing) return existing._id;

  return db.insert("conversationParticipants", {
    conversationId,
    userId,
    kind: "user",
    addedAt: Date.now(),
    status: "inactive",
    isRemoved: false,
  });
};

export const removeParticipant = async (
  db: DatabaseWriter,
  { participantId }: { participantId: Id<"conversationParticipants"> },
) => {
  await db.patch(participantId, {
    isRemoved: true,
  });
};

export const findParticipantByConversationIdAndIdentifier = async (
  db: DatabaseReader,
  {
    conversationId,
    identifier,
  }: {
    conversationId: Id<"conversations">;
    identifier: typeof conversationParticipantIdentifierSchemaValidator.type;
  },
) => {
  if (identifier.kind === "agent") {
    return await db
      .query("conversationParticipants")
      .withIndex("by_conversationId_kind_agentId", (q) =>
        q
          .eq("conversationId", conversationId)
          .eq("kind", "agent")
          .eq("agentId", identifier.agentId),
      )
      .first();
  }

  if (identifier.kind === "user") {
    return await db
      .query("conversationParticipants")
      .withIndex("by_conversationId_kind_userId", (q) =>
        q
          .eq("conversationId", conversationId)
          .eq("kind", "user")
          .eq("userId", identifier.userId),
      )
      .first();
  }

  exhaustiveCheck(identifier);
};

export const getParticipantByConversationIdAndIdentifier = async (
  db: DatabaseReader,
  args: {
    conversationId: Id<"conversations">;
    identifier: typeof conversationParticipantIdentifierSchemaValidator.type;
  },
) => {
  const participant = await findParticipantByConversationIdAndIdentifier(
    db,
    args,
  );
  if (!participant) throw new Error(`Participant not found ${args.identifier}`);
  return participant;
};

export const findUserParticipantInConversation = async (
  db: DatabaseReader,
  {
    conversationId,
    userId,
  }: { conversationId: Id<"conversations">; userId: Id<"users"> },
) => {
  return await findParticipantByConversationIdAndIdentifier(db, {
    conversationId,
    identifier: { kind: "user", userId },
  });
};

export const getMyParticipant = async (
  ctx: QueryCtx,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const userId = await Users.getMyId(ctx);
  const participant = await findParticipantByConversationIdAndIdentifier(
    ctx.db,
    {
      conversationId,
      identifier: { kind: "user", userId },
    },
  );
  if (!participant) throw new Error(`Participant not found ${userId}`);
  return participant;
};

export const doesHaveAgent = async (
  db: DatabaseReader,
  {
    conversationId,
    agentId,
  }: { conversationId: Id<"conversations">; agentId: Id<"agents"> },
) => {
  const conversationParticipant =
    await findParticipantByConversationIdAndIdentifier(db, {
      conversationId,
      identifier: { kind: "agent", agentId },
    });
  return !!conversationParticipant;
};

export const doesHaveTriageAgent = async (
  db: DatabaseReader,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const triageAgent = await Agents.getTriageAgent(db);
  return doesHaveAgent(db, { conversationId, agentId: triageAgent._id });
};

export const getParticipantDetails = async (
  db: DatabaseReader,
  participant: Doc<"conversationParticipants">,
  options?: {
    includeDescription?: boolean;
    isCreator?: (participant: Doc<"conversationParticipants">) => boolean;
  },
) => {
  if (participant.kind === "agent") {
    const agent = await db.get(participant.agentId);
    if (!agent) return null;
    return {
      id: participant._id,
      name: agent.name,
      avatarUrl: agent.avatarUrl,
      kind: "agent",
      ...(options?.includeDescription && { description: agent.description }),
      ...(options?.includeDescription && {
        isSystem: agent.kind === "system_agent",
      }),
      isCreator: false,
    };
  } else {
    const user = await db.get(participant.userId);
    if (!user) return null;
    return {
      id: participant._id,
      name: user.name ?? "Unknown User",
      avatarUrl:
        user.image ??
        `https://api.dicebear.com/7.x/avataaars/svg?seed=${user._id}`,
      kind: "user",
      isCreator: options?.isCreator?.(participant) ?? false,
    };
  }
};

export const listNonSystemAgentParticipants = async (
  db: DatabaseReader,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const participants = await getNonRemovedParticipants(db, { conversationId });

  // Filter to only agent participants and get their details
  const agentParticipants = await Promise.all(
    participants
      .filter((p) => p.kind === "agent")
      .map(async (p) => {
        if (p.kind !== "agent") return null; // TypeScript narrowing
        const agent = await Agents.find(db, { agentId: p.agentId });
        if (!agent || agent.kind === "system_agent") return null;
        return {
          participant: p,
          agent,
        };
      }),
  );

  return agentParticipants.filter(
    (p): p is NonNullable<typeof p> => p !== null,
  );
};

export const listParticipantsWithJoinedDetails = async (
  db: DatabaseReader,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const participants = await getNonRemovedParticipants(db, { conversationId });

  const participantsWithDetails = await Promise.all(
    participants.map(async (participant) => {
      if (participant.kind === "agent")
        return {
          participant,
          agent: await Agents.get(db, { agentId: participant.agentId }),
        };

      if (participant.kind === "user")
        return {
          participant,
          user: await Users.get(db, { userId: participant.userId }),
        };

      exhaustiveCheck(participant);
    }),
  );

  return participantsWithDetails;
};

export const getNonSystemAgentParticipants = async (
  db: DatabaseReader,
  args: { conversationId: Id<"conversations"> },
) => {
  const participants = await listNonSystemAgentParticipants(db, args);
  if (!participants)
    throw new Error(
      `No non-system agent participants found for conversation '${args.conversationId}'`,
    );
  return participants;
};

export const deleteAllParticipantsForConversation = async (
  db: DatabaseWriter,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const participants = await db
    .query("conversationParticipants")
    .withIndex("by_conversationId", (q) =>
      q.eq("conversationId", conversationId),
    )
    .collect();

  await Promise.all(
    participants.map((participant) => db.delete(participant._id)),
  );
};
</file>

<file path="src/components/authenticated/chat/ChatArea.tsx">
import * as React from "react";
import { ChatMessage } from "./ChatMessage";
import { ChatInput } from "./ChatInput";
import { ConversationHeader } from "./ConversationHeader";
import { ThinkingIndicator } from "./ThinkingIndicator";
import { Skeleton } from "../../ui/skeleton";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";
import { ChatProvider } from "./ChatContext";

interface ChatAreaProps {
  conversationId: Id<"conversations">;
}

export const ChatArea: React.FC<ChatAreaProps> = ({ conversationId }) => {
  const messagesEndRef = React.useRef<HTMLDivElement>(null);
  const conversation = useQuery(api.conversations.queries.findMine, {
    conversationId,
  });
  const messages = useQuery(api.conversationMessages.queries.listForMe, {
    conversationId,
  });

  const scrollToBottom = React.useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, []);

  React.useEffect(() => {
    scrollToBottom();
  }, [messages, scrollToBottom]);

  return (
    <ChatProvider>
      <div className="flex flex-col h-screen bg-background">
        <ConversationHeader conversation={conversation} />
        <div className="relative flex-1">
          <div className="absolute inset-0 flex flex-col-reverse">
            <div className="absolute bottom-0 left-0 right-0">
              <ChatInput conversationId={conversationId} />
            </div>
            <div className="overflow-y-auto pb-24">
              <div className="p-4 space-y-4">
                {!messages ? (
                  <>
                    <div className="flex justify-start">
                      <Skeleton className="h-24 w-2/3" />
                    </div>
                    <div className="flex justify-end">
                      <Skeleton className="h-16 w-1/2" />
                    </div>
                    <div className="flex justify-start">
                      <Skeleton className="h-20 w-3/5" />
                    </div>
                  </>
                ) : (
                  <>
                    {messages.map((message) => (
                      <ChatMessage key={message._id} message={message} />
                    ))}
                    <ThinkingIndicator conversationId={conversationId} />
                  </>
                )}
                <div ref={messagesEndRef} />
              </div>
            </div>
          </div>
        </div>
      </div>
    </ChatProvider>
  );
};
</file>

<file path="package.json">
{
  "name": "agent-inbox",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "npm-run-all --parallel dev:frontend dev:backend",
    "dev:frontend": "vite --open",
    "dev:backend": "convex dev",
    "dev:ts": "tsc -b --watch --preserveWatchOutput",
    "predev": "convex dev --until-success && convex dashboard",
    "build": "tsc -b && vite build",
    "lint": "tsc && eslint .  --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "test": "vitest",
    "preview": "vite preview"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.2.6",
    "@auth/core": "0.37.0",
    "@convex-dev/auth": "^0.0.80",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@tailwindcss/vite": "^4.0.14",
    "@types/react-mentions": "^4.4.1",
    "ai": "^4.1.61",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "convex": "^1.21.0",
    "convex-helpers": "^0.1.73",
    "date-fns": "^4.1.0",
    "exa-js": "^1.5.12",
    "lucide-react": "^0.482.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-error-boundary": "^5.0.0",
    "react-markdown": "^10.1.0",
    "react-mentions": "^4.4.10",
    "remark-gfm": "^4.0.1",
    "resend": "^4.2.0",
    "sonner": "^2.0.1",
    "tailwind-merge": "^3.0.2",
    "tailwindcss-animate": "^1.0.7",
    "type-route": "^1.1.0",
    "xstate": "^5.19.2",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "dotenv": "^16.4.7",
    "@types/node": "^20.14.9",
    "@types/react": "^19.0.11",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.23.0",
    "@typescript-eslint/parser": "^8.23.0",
    "@vitejs/plugin-react": "^4.3.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.7",
    "npm-run-all": "^4.1.5",
    "prettier": "3.3.2",
    "tailwindcss": "^4.0.14",
    "typescript": "^5.8.2",
    "vite": "^6.2.2",
    "vitest": "^3.0.9"
  }
}
</file>

<file path="convex/ai/instructions.ts">
import { Doc } from "../_generated/dataModel";
import { ParticipantUserOrAgent } from "../conversationParticipants/model";

const referenceAgentInstructions = `You can reference an agent using the following special syntax: 
@[AGENT_NAME](agent:AGENT_ID) 
so for example:
"Hey @[John](agent:abc123) can you take a look at this?"

A referenced agent will then pick that up later. They will be able to see the message history and the message that referenced them.`;

const otherCommonInstructions = `When you are asked to do something at a future date you should use the scheduleTask tool and NOT do it immediately.

If you need more context to answer the question you should respond asking the user or another agent for more information.

You should not use the messageAnotherAgent tool to send a message to yourself.

If another agent has a tool that you dont have access to, you should respond with a reference to them and ask them to help you and give some context about what you are thinking.

You should update the conversation title if you notice that the current conversation has evolved to focus on a different topic or if the current title is too generic such as "New Conversation". 
`;

const triageInstructions = `You are a helpful agent that triages conversations.

You will be given a conversation message and it's up to you to determine what agent or agents you should route the message to.

YOU SHOULD NOT RESPOND TO THE QUERY DIRECTLY, ONLY TRIAGE THE MESSAGE.

You should respond with a reference to the agent you think should handle the message and they will see it and reply.

You should add participants to the conversation if you think they would be needed later on.

${otherCommonInstructions}

${referenceAgentInstructions}`;

const agentReplyInstructions = `You are an agent that is part of a conversation with yourself, other agents and other users. 

You will be given the history of the conversation where each message is prefixed with the participant who sent it. You should look at the history to see if you can find any information that might be relevant to the message you are responding to.

You can use the tools provided to you to help you respond to the message.

${referenceAgentInstructions}

${otherCommonInstructions}

When responding:
1. Look at the supplied message history for added context that might be important
2. If the user directly asked you a question, respond helpfully and directly
3. If you think another agent could help, use the reference syntax to mention them
4. If you were referenced by the Triage Agent you should always respond.
5. If you want to search the web for information, use the webSearch tool
6. You are encouraged to reference another agent or human if you think they can contribute to the conversation, use the listConversationParticipants tool to see who is in the conversation
`;

export type InstructionsArgs = {
  messageAuthor: ParticipantUserOrAgent;
  conversation: Doc<"conversations">;
  agent: Doc<"agents">;
};

export const constructAdditionalInstructionContext = ({
  conversation,
  messageAuthor,
  agent,
}: InstructionsArgs) => `Here is some extra info about you the agent:
${JSON.stringify(agent, null, 2)}

Here is some information about the message author:
${JSON.stringify(messageAuthor, null, 2)}

Here is some information about the conversation:
${JSON.stringify(conversation, null, 2)}
`;

export const constructTriageInstructions = (args: InstructionsArgs) =>
  `${triageInstructions}\n\n${constructAdditionalInstructionContext(args)}`;

export const constructAgentReplyInstructions = (args: InstructionsArgs) =>
  `${agentReplyInstructions}\n\n${constructAdditionalInstructionContext(args)}`;
</file>

<file path="convex/conversationMessages/internalActions.ts">
"use node";
import { internalAction } from "../_generated/server";
import schema from "../schema";
import { triageMessage } from "../ai/triageMessage";
import { doc } from "convex-helpers/validators";
import { agentReplyToMessage } from "../ai/agentReplyToMessage";
import { internal } from "../_generated/api";
import { parseMentionsFromMessageContent } from "../../shared/mentions";

export const processMessage = internalAction({
  args: {
    message: doc(schema, "conversationMessages"),
    conversation: doc(schema, "conversations"),
  },
  handler: async (ctx, args) => {
    // Dont handle system
    if (args.message.kind == "system") return;

    // If there are no references then we should invoke the "triage agent" which will    decide what to do with the message

    console.log(`Processing Message..`, args.message);

    const references = parseMentionsFromMessageContent(args.message.content);

    console.log(`Detected references`, references);

    if (references.length == 0) {
      const author = await ctx.runQuery(
        internal.conversationParticipants.internalQueries
          .getParticipantUserOrAgent,
        { participantId: args.message.authorParticipantId },
      );

      if (author.kind != "user") {
        console.log(`Not triaging agent messages`);
        return;
      }

      await triageMessage(ctx, {
        message: args.message,
        conversation: args.conversation,
        messageAuthor: author,
      });
    }

    // Otherwise we should invoke each agent with the message
    for (const reference of references) {
      if (reference.kind == "agent") {
        const author = await ctx.runQuery(
          internal.conversationParticipants.internalQueries
            .getParticipantUserOrAgent,
          { participantId: args.message.authorParticipantId },
        );
        await agentReplyToMessage(ctx, {
          message: args.message,
          agentId: reference.agentId,
          conversation: args.conversation,
          messageAuthor: author,
        });
      }
    }
  },
});
</file>

<file path="convex/ai/tools.ts">
"use node";
import { ActionCtx } from "../_generated/server";
import { internal, api } from "../_generated/api";
import { Doc, Id } from "../_generated/dataModel";
import { tool } from "ai";
import { sendSystemMessageToConversation } from "./utils";
import Exa from "exa-js";
import { pick } from "convex-helpers";
import { Resend } from "resend";
import {
  toolDefinitions,
  AgentToolName,
  alwaysIncludedTools,
} from "../../shared/tools";

const exa = new Exa(process.env.EXA_API_KEY);
const resend = new Resend(process.env.RESEND_API_KEY);

export const createTools = ({
  ctx,
  agent,
  conversation,
  agentParticipant,
}: {
  ctx: ActionCtx;
  agent: Doc<"agents">;
  agentParticipant: Doc<"conversationParticipants">;
  conversation: Doc<"conversations">;
}) => ({
  [toolDefinitions.listConversationParticipants.name]: tool({
    description: toolDefinitions.listConversationParticipants.description,
    parameters: toolDefinitions.listConversationParticipants.parameters,
    execute: async ({ conversationId }) => {
      await sendSystemMessageToConversation(ctx, {
        content: `${agent.name} is listing participants in the conversation ${conversation._id}`,
        conversationId: conversation._id,
        meta: {
          toolName: "listConversationParticipants",
          agentName: agent.name,
        },
      });
      const participants = await ctx.runQuery(
        internal.conversationParticipants.internalQueries
          .listNonSystemAgentParticipantsWithJoinedDetails,
        {
          conversationId: conversationId as Id<"conversations">,
        },
      );

      // Lets turn them into the mention format which I hope is more AI compatible
      return participants.map((p) => {
        if (p.agent)
          return {
            kind: "agent",
            ...pick(p.agent, [
              "_id",
              "name",
              "description",
              "personality",
              "tools",
            ]),
          };

        if (p.user)
          return {
            kind: "user",
            ...pick(p.user, ["_id", "name", "email"]),
          };

        return null;
      });
    },
  }),

  [toolDefinitions.listAgents.name]: tool({
    description: toolDefinitions.listAgents.description,
    parameters: toolDefinitions.listAgents.parameters,
    execute: async ({ userId }) => {
      console.log(`using tool: listAgents`, { userId });

      await sendSystemMessageToConversation(ctx, {
        content: `${agent.name} is listing the users agents ${conversation._id}`,
        conversationId: conversation._id,
        meta: { toolName: "listAgents", userId, agentName: agent.name },
      });

      return await ctx.runQuery(
        internal.agents.internalQueries.listAgentsForUser,
        {
          userId: userId as Id<"users">,
        },
      );
    },
  }),

  [toolDefinitions.messageAnotherAgent.name]: tool({
    description: toolDefinitions.messageAnotherAgent.description,
    parameters: toolDefinitions.messageAnotherAgent.parameters,
    execute: async ({ target, content }) => {
      return await ctx.runMutation(
        internal.conversationMessages.internalMutations.sendFromAgent,
        {
          conversationId: conversation._id,
          content: `@[${target.agentName}](agent:${target.agentId}) ${content}`,
          agentId: agent._id,
          authorParticipantId: agentParticipant._id,
        },
      );
    },
  }),

  [toolDefinitions.noOutput.name]: tool({
    description: toolDefinitions.noOutput.description,
    parameters: toolDefinitions.noOutput.parameters,
  }),

  [toolDefinitions.webSearch.name]: tool({
    description: toolDefinitions.webSearch.description,
    parameters: toolDefinitions.webSearch.parameters,
    execute: async ({ query }) => {
      await sendSystemMessageToConversation(ctx, {
        content: `${agent.name} is searching the web for "${query}"`,
        conversationId: conversation._id,
        meta: { toolName: "webSearch", query, agentName: agent.name },
      });
      const result = await exa.answer(query, { text: true });
      console.log(`webSearch result:`, result);
      return pick(result, ["answer", "citations"]);
    },
  }),

  [toolDefinitions.updateConversationTitle.name]: tool({
    description: toolDefinitions.updateConversationTitle.description,
    parameters: toolDefinitions.updateConversationTitle.parameters,
    execute: async ({ title }) => {
      await ctx.runMutation(internal.conversations.internalMutations.update, {
        conversationId: conversation._id,
        title,
      });

      await sendSystemMessageToConversation(ctx, {
        content: `${agent.name} updated the conversation title to "${title}"`,
        conversationId: conversation._id,
        meta: {
          toolName: "updateConversationTitle",
          newTitle: title,
          agentName: agent.name,
        },
      });

      return {
        result: "title_updated",
        newTitle: title,
      };
    },
  }),

  [toolDefinitions.scheduleTask.name]: tool({
    description: toolDefinitions.scheduleTask.description,
    parameters: toolDefinitions.scheduleTask.parameters,
    execute: async ({ content, secondsFromNow, target, title }) => {
      await sendSystemMessageToConversation(ctx, {
        content: `${agent.name} scheduled a task "${title}" to be sent in ${secondsFromNow} seconds`,
        conversationId: conversation._id,
        meta: {
          toolName: "scheduleTask",
          title,
          secondsFromNow,
          target,
          content,
          agentName: agent.name,
        },
      });

      const scheduledMessageId = await ctx.scheduler.runAfter(
        secondsFromNow * 1000,
        internal.conversationMessages.internalMutations.sendFromAgent,
        {
          conversationId: conversation._id,
          content: `@[${target.agentName}](agent:${target.agentId}) ${content}`,
          agentId: agent._id,
          authorParticipantId: agentParticipant._id,
        },
      );

      return {
        result: "message_sent",
        scheduledMessageId,
      };
    },
  }),

  [toolDefinitions.sendEmail.name]: tool({
    description: toolDefinitions.sendEmail.description,
    parameters: toolDefinitions.sendEmail.parameters,
    execute: async ({ to, subject, content, from }) => {
      await sendSystemMessageToConversation(ctx, {
        content: `${agent.name} is sending an email to "${to}" with the subject "${subject}"`,
        conversationId: conversation._id,
        meta: {
          toolName: "sendEmail",
          to,
          subject,
          content,
          from,
          agentName: agent.name,
        },
      });

      try {
        const response = await resend.emails.send({
          to,
          subject,
          html: content,
          from: "mike.cann@convex.dev",
        });

        if (response.error)
          throw new Error(`Failed to send email: ${response.error.message}`);

        return {
          result: "email_sent",
        };
      } catch (error: any) {
        console.error("Failed to send email:", error);
        throw new Error(
          `Failed to send email: ${error?.message ?? "Unknown error"}`,
        );
      }
    },
  }),

  [toolDefinitions.addParticipantToConversation.name]: tool({
    description: toolDefinitions.addParticipantToConversation.description,
    parameters: toolDefinitions.addParticipantToConversation.parameters,
    execute: async ({ agentId }) => {
      try {
        await sendSystemMessageToConversation(ctx, {
          content: `${agent.name} is adding an agent with ID ${agentId} to the conversation`,
          conversationId: conversation._id,
          meta: {
            toolName: "addParticipantToConversation",
            agentId,
            agentName: agent.name,
          },
        });

        const participant = await ctx.runMutation(
          internal.conversationParticipants.internalMutations
            .addAgentIfNotAlreadyJoined,
          {
            conversationId: conversation._id,
            agentId: agentId as Id<"agents">,
          },
        );

        return {
          result: "participant_added",
          participantId: participant,
          type: "agent",
        };
      } catch (error: any) {
        console.error("Failed to add agent:", error);
        throw new Error(
          `Failed to add agent: ${error?.message ?? "Unknown error"}`,
        );
      }
    },
  }),
});

export const createToolsForAgent = ({
  ctx,
  agent,
  conversation,
  agentParticipant,
}: {
  ctx: ActionCtx;
  agent: Doc<"agents">;
  agentParticipant: Doc<"conversationParticipants">;
  conversation: Doc<"conversations">;
}) => {
  const allTools = createTools({ ctx, agent, conversation, agentParticipant });
  return pick(allTools, [
    ...(Object.keys(alwaysIncludedTools) as AgentToolName[]),
    ...(agent.tools as AgentToolName[]),
  ]);
};
</file>

<file path="convex/conversationMessages/model.ts">
import {
  DatabaseReader,
  DatabaseWriter,
  MutationCtx,
  QueryCtx,
} from "../_generated/server";
import { Doc, Id } from "../_generated/dataModel";
import { internal } from "../_generated/api";
import { ensureFP } from "../../shared/ensure";
import * as ConversationParticipants from "../conversationParticipants/model";
import { conversationAgentMessageSchemaValidator } from "./schema";
import { ParticipantUserOrAgent } from "../conversationParticipants/model";

export const addMessageToConversationFromUserOrAgent = async (
  ctx: MutationCtx,
  args: {
    conversationId: Id<"conversations">;
    content: string;
    authorParticipantId: Id<"conversationParticipants">;
  },
) => {
  // Create the message
  const messageId = await ctx.db.insert("conversationMessages", {
    ...args,
    kind: "participant",
  });

  // Update conversation's last message time
  await ctx.db.patch(args.conversationId, {
    lastMessageTime: Date.now(),
  });

  // Schedule a task to process the message
  await ctx.scheduler.runAfter(
    0,
    internal.conversationMessages.internalActions.processMessage,
    {
      message: await ctx.db.get(messageId).then(ensureFP()),
      conversation: await ctx.db.get(args.conversationId).then(ensureFP()),
    },
  );

  return messageId;
};

export const addMessageToConversationFromSystem = async (
  db: DatabaseWriter,
  args: {
    conversationId: Id<"conversations">;
    content: string;
    meta?: any;
  },
) => {
  // Create the message
  return await db.insert("conversationMessages", {
    kind: "system",
    conversationId: args.conversationId,
    content: args.content,
    ...(args.meta !== undefined && { meta: args.meta }),
  });
};

export const addMessageToConversationFromMe = async (
  ctx: MutationCtx,
  args: {
    conversationId: Id<"conversations">;
    content: string;
  },
) => {
  const participant = await ConversationParticipants.getMyParticipant(ctx, {
    conversationId: args.conversationId,
  });

  const messageId = await addMessageToConversationFromUserOrAgent(ctx, {
    ...args,
    authorParticipantId: participant._id,
  });

  return messageId;
};

export const addMessageToConversationFromAgent = async (
  ctx: MutationCtx,
  {
    authorParticipantId,
    content,
    conversationId,
  }: {
    conversationId: Id<"conversations">;
    agentId: Id<"agents">;
    content: string;
    authorParticipantId: Id<"conversationParticipants">;
  },
) => {
  return await addMessageToConversationFromUserOrAgent(ctx, {
    conversationId,
    content,
    authorParticipantId,
  });
};

export const listMessages = async (
  db: DatabaseReader,
  {
    conversationId,
    limit = 100,
    kind,
  }: {
    conversationId: Id<"conversations">;
    kind?: typeof conversationAgentMessageSchemaValidator.type.kind;
    limit?: number;
  },
) => {
  if (kind) {
    return await db
      .query("conversationMessages")
      .withIndex("by_conversationId", (q) =>
        q.eq("conversationId", conversationId),
      )
      .order("desc")
      .take(limit)
      .then((messages) => messages.reverse());
  }

  return await db
    .query("conversationMessages")
    .withIndex("by_conversationId", (q) =>
      q.eq("conversationId", conversationId),
    )
    .order("desc")
    .take(limit)
    .then((messages) => messages.reverse());
};

// export const listMessagesAndJoinAuthorDetails = async (
//   ctx: QueryCtx,
//   {
//     conversationId,
//     limit = 50,
//   }: {
//     conversationId: Id<"conversations">;
//     limit?: number;
//   },
// ) => {
//   const messages = await listMessages(ctx, {
//     conversationId,
//     limit,
//   });

//   const messagesWithAuthorDetails = await Promise.all(
//     messages.map(async (message) => {
//       const userOrAgent =
//         await ConversationParticipants.getParticipantUserOrAgent(ctx.db, {
//           participantId: message.author,
//         });
//       return { message, author: userOrAgent };
//     }),
//   );

//   // Fetch avatar URLs and names for each message
//   // const messagesWithAvatars = await Promise.all(
//   //   messages.map(async (message) => {
//   //     if (message.author.kind === "user") {
//   //       const user = await ctx.db.get(message.author.userId);
//   //       if (!user) return { ...message, avatarUrl: null };
//   //       return {
//   //         ...message,
//   //         avatarUrl:
//   //           user.image ??
//   //           `https://api.dicebear.com/7.x/avataaars/svg?seed=${user._id}`,
//   //       };
//   //     }

//   //     if (message.author.kind === "agent") {
//   //       const agent = await ctx.db.get(message.author.agentId);
//   //       if (!agent) return { ...message, avatarUrl: null };
//   //       return {
//   //         ...message,
//   //         avatarUrl: agent.avatarUrl,
//   //       };
//   //     }

//   //     if (message.author.kind === "system") {
//   //       return {
//   //         ...message,
//   //         avatarUrl: null,
//   //       };
//   //     }

//   //     exhaustiveCheck(message.author);
//   //   }),
//   // );

//   return messages;
// };

export const createParticipantJoinedConversationMessage = async (
  db: DatabaseWriter,
  args: {
    conversationId: Id<"conversations">;
    agentOrUser: Doc<"agents"> | Doc<"users">;
  },
) => {
  const name = args.agentOrUser.name ?? "Unknown";

  await addMessageToConversationFromSystem(db, {
    conversationId: args.conversationId,
    content: ` ${name} has joined the conversation.`,
  });
};

export const createParticipantLeftConversationMessage = async (
  db: DatabaseWriter,
  args: {
    conversationId: Id<"conversations">;
    participant: ParticipantUserOrAgent;
  },
) => {
  const name =
    args.participant.kind === "user"
      ? args.participant.user.name
      : args.participant.agent.name;

  await addMessageToConversationFromSystem(db, {
    conversationId: args.conversationId,
    content: ` ${name} has left the conversation.`,
  });
};

export const deleteAllMessagesForConversation = async (
  db: DatabaseWriter,
  { conversationId }: { conversationId: Id<"conversations"> },
) => {
  const messages = await db
    .query("conversationMessages")
    .withIndex("by_conversationId", (q) =>
      q.eq("conversationId", conversationId),
    )
    .collect();

  await Promise.all(messages.map((message) => db.delete(message._id)));
};
</file>

<file path="convex/_generated/api.d.ts">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";
import type * as agents_internalMutations from "../agents/internalMutations.js";
import type * as agents_internalQueries from "../agents/internalQueries.js";
import type * as agents_model from "../agents/model.js";
import type * as agents_mutations from "../agents/mutations.js";
import type * as agents_queries from "../agents/queries.js";
import type * as ai_agentReplyToMessage from "../ai/agentReplyToMessage.js";
import type * as ai_history from "../ai/history.js";
import type * as ai_instructions from "../ai/instructions.js";
import type * as ai_messages from "../ai/messages.js";
import type * as ai_tools from "../ai/tools.js";
import type * as ai_triageMessage from "../ai/triageMessage.js";
import type * as ai_utils from "../ai/utils.js";
import type * as auth from "../auth.js";
import type * as conversationMessages_internalActions from "../conversationMessages/internalActions.js";
import type * as conversationMessages_internalMutations from "../conversationMessages/internalMutations.js";
import type * as conversationMessages_internalQueries from "../conversationMessages/internalQueries.js";
import type * as conversationMessages_model from "../conversationMessages/model.js";
import type * as conversationMessages_mutations from "../conversationMessages/mutations.js";
import type * as conversationMessages_queries from "../conversationMessages/queries.js";
import type * as conversationParticipants_internalMutations from "../conversationParticipants/internalMutations.js";
import type * as conversationParticipants_internalQueries from "../conversationParticipants/internalQueries.js";
import type * as conversationParticipants_model from "../conversationParticipants/model.js";
import type * as conversationParticipants_mutations from "../conversationParticipants/mutations.js";
import type * as conversationParticipants_queries from "../conversationParticipants/queries.js";
import type * as conversations_internalMutations from "../conversations/internalMutations.js";
import type * as conversations_internalQueries from "../conversations/internalQueries.js";
import type * as conversations_model from "../conversations/model.js";
import type * as conversations_mutations from "../conversations/mutations.js";
import type * as conversations_queries from "../conversations/queries.js";
import type * as http from "../http.js";
import type * as users_model from "../users/model.js";
import type * as users_queries from "../users/queries.js";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  "agents/internalMutations": typeof agents_internalMutations;
  "agents/internalQueries": typeof agents_internalQueries;
  "agents/model": typeof agents_model;
  "agents/mutations": typeof agents_mutations;
  "agents/queries": typeof agents_queries;
  "ai/agentReplyToMessage": typeof ai_agentReplyToMessage;
  "ai/history": typeof ai_history;
  "ai/instructions": typeof ai_instructions;
  "ai/messages": typeof ai_messages;
  "ai/tools": typeof ai_tools;
  "ai/triageMessage": typeof ai_triageMessage;
  "ai/utils": typeof ai_utils;
  auth: typeof auth;
  "conversationMessages/internalActions": typeof conversationMessages_internalActions;
  "conversationMessages/internalMutations": typeof conversationMessages_internalMutations;
  "conversationMessages/internalQueries": typeof conversationMessages_internalQueries;
  "conversationMessages/model": typeof conversationMessages_model;
  "conversationMessages/mutations": typeof conversationMessages_mutations;
  "conversationMessages/queries": typeof conversationMessages_queries;
  "conversationParticipants/internalMutations": typeof conversationParticipants_internalMutations;
  "conversationParticipants/internalQueries": typeof conversationParticipants_internalQueries;
  "conversationParticipants/model": typeof conversationParticipants_model;
  "conversationParticipants/mutations": typeof conversationParticipants_mutations;
  "conversationParticipants/queries": typeof conversationParticipants_queries;
  "conversations/internalMutations": typeof conversations_internalMutations;
  "conversations/internalQueries": typeof conversations_internalQueries;
  "conversations/model": typeof conversations_model;
  "conversations/mutations": typeof conversations_mutations;
  "conversations/queries": typeof conversations_queries;
  http: typeof http;
  "users/model": typeof users_model;
  "users/queries": typeof users_queries;
}>;
export declare const api: FilterApi<
  typeof fullApi,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApi,
  FunctionReference<any, "internal">
>;
</file>

</files>
